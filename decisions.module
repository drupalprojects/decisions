<?php

/**
 * @file
 * Modular voting mechanisms, delegatable votes, taxonomy/category influenced controls and weighted voting
 * See http://decisions.gnuvernment.org for more information on the project.
 *
 * Heavily inspired by other Drupal modules, mostly from poll.module, but we adapted it to "drupal forms api".
 * Thanks to everyone for all the that was already written. (...and debugged!)
 */



/**
 * Implementation of hook_access().
 */
function decisions_access($op, $node) {
  global $user;

  if ($op == 'create') {
    return user_access('create decisions');
  }
  if ($op == 'delete') {
    return user_access('delete decisions');
  }
  if ($op == 'update') {
    /* if you can create it you can update it, provided it is your own... */
    if (user_access('create decisions') && ($user->uid == $node->uid)) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_block().
 */
function decisions_block($op = 'list', $delta = 0, $edit = array()) {
  switch($op) {
    case 'list' :
      $blocks[0]['info'] = t('A decisions block');
      return $blocks;
    case 'view' :
      $blocks["content"] = decisions_block_contents();
      $blocks["subject"] = "decisions";
      return $blocks;
  }
}

/**
 * Content of the block, as returned by decisions_block('view')
 */
function decisions_block_contents() {
  $block = '';
  if ( user_access('view decisions') ) {
    /* get list of decisions and show them */
    if ( user_access('vote on decisions') ) {
      /* add a link to vote on the decision */
    }
  }
  return $block;
}

/**
 * Implementation of hook_delete().
 *
 * TODO: to test
 * TODO: do we remove the votes themselves?
 */
function decisions_delete($node) {
  db_query("DELETE FROM {decisions} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {decisions_options} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {decisions_electoral_list} WHERE nid = %d", $node->nid);
}

/**
 * Implementation of hook_form().
 *
 * This hook displays the form necessary to edit the *node* (ie. not the votes).
 */
function decisions_form($node) {

  /* standard node elements */
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#required' => TRUE,
    '#default_value' => $node->title,
  );
  $form['body'] = array(
    '#type' => 'textarea',
    '#title' => t('Description'),
    '#required' => FALSE,
    '#default_value' => $node->body,
  );

  $form['mode'] = array(
    '#type' => 'select',
    '#title' => t('Decision mode'),
    '#required' => TRUE,
    '#options' => array( 'poll' => t('Poll'), 'runoff' => t('Runoff') ),
    '#default_value' => variable_get('mode', 'poll'),
  );

  /* decision-specific elements */
  /* this code is mostly from poll.module */
  if (!isset($node->options)) {
    $node->options = 5;
  }
  // User ticked 'need more choices'.
  if ($_POST['edit']['OptionGroup']['moreoptions']) {
    if (!$node->options)
        $node->options = 2;
    else
    	$node->options *= 2;
   }

  // Options list
  $form['OptionGroup'] = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#title' => t('Options'),
    '#collapsible' => TRUE,
  );
  for ( $option_number = 1; $option_number <= $node->options; $option_number++ ) {
    $form['OptionGroup']['Option_'.$option_number] = array(
      '#type' => 'textfield',
      '#title' => t('Option %n', array('%n' => $option_number)),
      '#required' => FALSE,
      '#default_value' => $node->option[$option_number],
      '#size' => 50,
      '#maxlength' => 127,
    );
  }

  $form['OptionGroup']['options'] = array(
    '#type' => 'hidden',
    '#value' => $node->options,
  );
  $form['OptionGroup']['moreoptions'] = array(
    '#type' => 'checkbox',
    '#title' => t('Need more options'),
    '#default_value' => FALSE,
    '#description' => t("If the amount of boxes above isn't enough, check this box and click the Preview button below to add some more."),
  );

  return array_merge($form, filter_form($node->format));
}


/**
 * Implementation of hook_help().
 */
function decisions_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Allow people to reproduce and surpass the kinds of decision-making instances that exist in face-to-face meetings.');
    case 'node/add#decisions':
      return t('Submit a new decision to the electoral list.');
  }
}

/**
 * Implementation of hook_load().
 *
 * Load the votes and decision-specific data into the node object.
 */
function decisions_load($node) {
   $decision = db_fetch_object(db_query("SELECT * FROM {decisions} WHERE nid = %d", $node->nid));
   $result = db_query("SELECT optorder, opttext FROM {decisions_options} WHERE nid = %d ORDER BY optorder", $node->nid);
   while ($option = db_fetch_array($result)) {
   	$decision->option[$option['optorder']] = $option['opttext'];
   }
   $decision->options = count($decision->option);
   return $decision;
}

/**
 * Implementation of hook_menu().
 *
 * Just a path for creating new decisions for now, but we could
 * eventually have a 'my decisions' and 'view decisions' kind of
 * page. (TODO)
 */
function decisions_menu($may_cache) {
  global $user;

  $items = array();

  if ($may_cache) {
    $items[] = array('path' => 'node/add/decisions', 'title' => t('decision'),
      'access' => user_access('create decisions'));
    /*
    $items[] = array('path' => 'decisions', 'title' => t('decisions'),
      'callback' => 'decision_page',
      'access' => user_access('view decisions'),
      'type' => MENU_SUGGESTED_ITEM);
    $items[] = array('path' => 'decisions/'. $user->uid, 'title' => t('my decisions'),
      'access' => user_access('create decisions'),
      'type' => MENU_DYNAMIC_ITEM);
    */
  }

  return $items;
}

/**
 * Implementation of hook_node_info().
 */
function decisions_node_info() {
  return array('decisions' => array('name' => t('decision'), 'base' => 'decisions'));
}

/**
 * Implementation of hook_perm().
 */
function decisions_perm() {
  return array('create decisions', 'delete decisions', 'view decisions', 'vote on decisions');
}

/**
 * Implementation of hook_settings().
 *
 * Not configurable yet.
 */
function decisions_settings() {
  $output = '';
  return $output;
}

/**
 * Implementation of hook_update().
 *
 * This is called upon node edition.
 */
function decisions_update($node) {
  db_query("UPDATE {decisions} SET mode = '%s' WHERE nid = %d", $node->mode, $node->nid);
  # XXX: should update decisions here, when it has some parameters
  # XXX: ... but before doing so, the code below must be factored out in a seperate function for usage in decisions_insert()
  db_query('DELETE FROM {decisions_options} WHERE nid = %d', $node->nid);

  foreach ($node->OptionGroup as $key => $option) {
  	$order = str_replace('Option_', '', $key);
	if ($order != $key && $option != '') {
		db_query("INSERT INTO {decisions_options} (nid, opttext, optorder) VALUES (%d, '%s', %d)", $node->nid, $option, intval($order));
	   }
	# ignore entries other than options
  }
}

/**
 * Implementation of hook_insert()
 *
 * This is called upon node creation
 */
function decisions_insert($node) {
  # just create an empty entry for now
  db_query("INSERT INTO {decisions} (nid, mode) VALUES (%d, '%s')", $node->nid, $node->mode);

  # create the electoral list
  db_query("INSERT INTO {decisions_electoral_list} (nid, uid) SELECT '%d', u.uid FROM users_roles u, permission p WHERE p.perm LIKE '%view decisions%' AND u.rid = p.rid", $node->nid);

  # insert the options, same sequence than update
  decisions_update($node);
}

/**
 * Implementation of hook_validate().
 *
 * XXX: No validation yet.
 */
function decisions_validate($node) {
  // faut appeler form_set_error si necessaire
}

/**
 * Implementation of hook_view().
 */
function decisions_view(&$node, $teaser = FALSE, $page = FALSE, $block = FALSE) {
  $node = node_prepare($node, $teaser);
  $output .= decisions_view_voting($node, $teaser, $page, $block);
  $output .= decisions_view_results(&$node, $teaser, $page, $block);

  $node->body .= $output;
  $node->teaser .= $output;

}

/**
 * Theme stub for redering the voting form, to allow the chance for
 * themes to make this nicer/different
 */
function theme_decisions_view_voting($form) {
  $output .= '<div class="decisions">';
  $output .= '  <div class="option-form">';
  $output .= '    <div class="options">';
  $output .= form_render($form['option']);
  $output .= '    </div>';
  $output .= form_render($form['nid']);
  $output .= form_render($form['vote']);
  $output .= '  </div>';
  $output .= form_render($form);
  $output .= '</div>';
  return $output;
}

/**
 * View the voting form.
 *
 * This calls a function decisions_vote_$mode, where $mode is defined
 * in the node. If the function does not exist, a watchdog error is
 * raised and the error is reported using drupal_set_message().
 *
 * This also takes care of registering new votes, if the vote button
 * has been pressed.
 */
function decisions_view_voting(&$node, $teaser, $page, $block) {

  $mode = $node->mode;

  if ($_POST['op'] == t('Vote')) {
    if ( function_exists("decisions_vote_$mode") ) {
      call_user_func("decisions_vote_$mode", $node);
    }
  }
  if ( function_exists("decisions_view_voting_$mode") ) {
    return call_user_func("decisions_view_voting_$mode", $node, $teaser, $page, $block);
  }
  else {
    watchdog('decisions', t('Unknown decision mode : %mode.', array('%mode' => $node->mode), WATCHDOG_ERROR));
    drupal_set_message(t('Unknown decision mode : %mode.', array('%mode' => $node->mode), 'error'));
  }
}


/**
 * Implementation of the view_voting_() hook for the runoff module.
 *
 * This displays a textfield per options, that should be filled with a
 * ranking.
 *
 * TODO: make this a nicer UI (http://drupal.org/node/48255)
 */
function decisions_view_voting_runoff(&$node, $teaser, $page, $block) {
  if ($node->option) {
    $list = array();
    foreach ($node->option as $key => $option) {
      $list[$i] = check_plain($option);

      $form['OptionGroup']['Option_' . $key] = array(
        '#type' => 'textfield',
        '#title' => check_plain($option),
        '#required' => FALSE,
/*        '#default_value' => $node->option[$key],*/
        '#size' => 3,
        '#maxlength' => 3,
      );
    }
  }

  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $node->nid
  );
  $form['vote'] = array(
    '#type' => 'submit',
    '#value' => t('Vote')
  );
  $form['#action'] = url('node/'. $node->nid);
  return drupal_get_form('decisions_view_voting', $form);
}

/**
 * Implementation of the vote hook for the runoff module.
 *
 * This takes care of registering the vote in runoff nodes.
 */
function decisions_vote_runoff($node) {
  foreach ( $node->option AS $key => $option ) {
    $vote->value = $_POST['edit']['Option_' . $key];
    $vote->value_type = VOTINGAPI_VALUE_TYPE_KEY;
    $vote->tag = $key;
    votingapi_set_vote('decisions', $node->nid, $vote);
  }
}

/**
 * Implementation of the view_voting hook for the poll module.
 * 
 * This creates a list of radios to allow the user to vote on a single
 * poll option.
 */
function decisions_view_voting_poll(&$node, $teaser, $page, $block) {
  if ($node->option) {
    $list = array();
    foreach ($node->option as $i => $option) {
      $list[$i] = check_plain($option);
    }
    $form['option'] = array(
      '#type' => 'radios',
      '#title' => $page ? '' : check_plain($node->title),
      '#default_value' => -1,
      '#options' => $list
    );
  }
  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $node->nid
  );
  $form['vote'] = array(
    '#type' => 'submit',
    '#value' => t('Vote')
  );
  $form['#action'] = url('node/'. $node->nid);
  return drupal_get_form('decisions_view_voting', $form);
}

/**
 * show results of the vote
 *
 * this calls the appropriate vote results function, depending on the
 * mode. It will call decisions_view_results_$mode, similarly to
 * decisions_view_voting().
 */
function decisions_view_results(&$node, $teaser, $page, $block) {
  $mode = $node->mode;
  if ( function_exists("decisions_view_results_$mode") ) {
    return call_user_func("decisions_view_results_$mode", $node, $teaser, $page, $block);
  } else {
    watchdog('decisions', t('Unknown decision mode : %mode.', array('%mode' => $node->mode), WATCHDOG_ERROR));
    drupal_set_message(t('Unknown decision mode : %mode.', array('%mode' => $node->mode), 'error'));
  }
}

/**
 * implementation of the decisions_view_results() hook for the runoff
 * module
 *
 * TODO: fix display (http://drupal.org/node/48248)
 */
function decisions_view_results_runoff($node, $teaser, $page, $block) {
    $runoff = decision_calculate_runoff($node);
    $winning_option = $node->option[$runoff->winner];
    $output = "The winner is option $winning_option";
    
    // On output la table 
    $output .= "<table><tr><td>round</td>";
    foreach ($node->option as $key => $optionname) {
      $output .= "<td>$optionname</td>";
    }
    $output .= "</tr>";
    $round = 1;
    foreach ($runoff->matrix as $aRound) {
      $output .= "<tr><td>r-$round</td>";
      foreach ($node->option as $key => $optionname) { 
        $output .= "<td>$aRound[$key]</td>";
      }
      $output .= "</tr>";
      $round = $round + 1;
    }
     
 
    $output .= "</table>";
    return $output;
}

/**
 * Implemntation of the decisions_view_results() hook for the poll module
 *
 * TODO: implement (http://drupal.org/node/48249)
 */
function decisions_view_results_poll($node, $teaser, $page, $block) {
  return "FIXME: can't show results for poll yet";
}

function decision_calculate_runoff ($node) {

  $votes = _votingapi_get_raw_votes('decisions', $node->nid);
 
  //calculate the first round
  foreach ($votes as $vote) {
    if ($vote->value == 1) {
         $aRound[$vote->tag] = $aRound[$vote->tag] + 1;
         $totalvotes = $totalvotes + 1;
    }
  }
  
  while (true) {

    //Add the round to the matrix 
    $runoff_matrix[] = $aRound;

    //calculate the min and max number of vote
    $min = 100000000; // weird min
    $num_discarded = 0;
    foreach ($aRound as $votevalue) {

      if ($max < $votevalue) {
       $max = $votevalue;
      }
      if (($min > $votevalue) && ($votevalue != 0)) {
       $min = $votevalue;
      }
      if (!$votevalue) {  // si c'est à zéro, on le compte
       $num_discarded = $num_discarded + 1;
     }
    }

    // is there only two options left
    $twooptionsleft =  ((sizeof($aRound) - $num_discarded) == 2);

   
    // if max has the majority, it wins
    if (($max > $totalvotes/2) or $twooptionsleft) {
       $runoff->winner = array_search($max, $aRound);
       $runoff->matrix = $runoff_matrix;
       return $runoff;
    }

    //sinon, on trouve le prochainround
    $aRound = decision_calculate_runoff_nextround($aRound, $votes, $min);
   }
}

function decision_calculate_runoff_nextround($aRound, &$votes, $min) {

   // For Tie-breaking rules, lets implement in this first version the 
   // RANDOM: Eliminate one randomly to break the tie.
   // http://en.wikipedia.org/wiki/Instant-runoff_voting

   // What do we need to do here: 
   // "The votes for Nashville have Chattanooga as a second choice, but      as Chattanooga has been eliminated, they instead transfer to      their third choice, Knoxville."
   // http://en.wikipedia.org/wiki/Instant-runoff_voting
   // Autrement dit, si le second choix est éliminé, il faut regardé le troisième choix. 

   // step 1: find the loser and put 0 to it
   $taglooser = array_search($min, $aRound);  // random elimination
   $aRound[$taglooser] = 0;


   // step 2: lets find which users needs their vote to be redistributed
   $numbervotes_redistributed = 0;
   $preference_value = 0;
   while (($numbervotes_redistributed < $min) and $stop < 50){
      $preference_value = $preference_value + 1;
      foreach ($votes as $vote) {
        // step 2.1: find the users who voted for the loosers
        if (($vote->tag == $taglooser) and 
            ($vote->value == $preference_value) ) {
             $voteslosts[] = $vote->uid;
             $numbervotes_redistributed = $numbervotes_redistributed + 1;
         }
       }
       $stop = $stop+1;
    }

   // step 3: lets find what are the other non-eliminated choices for the ones who voted for the loosers.  Super pas optimal
   foreach ($voteslosts as $voteuid) {
     $minvalue = 0;
    foreach ($votes as $vote) {
       if (($vote->uid == $voteuid) and 
	($aRound[$vote->tag] != 0) and 
	($aRound[$vote->value] > $minvalue) ) {
             $votesecond[$voteuid] = $vote->tag;
             $vote->value = 1;
             $minvalue = $vote->value;
       	} 	
     }
   }

   // step 4: distribute the second vote for all the loosers
   foreach ($voteslosts as $votelost_uid) {
     $aRound[$votesecond[$votelost_uid]] += 1;
   }

   return $aRound;
}

function decisions_vote_poll($node) {
  $vote->value = $_POST['edit']['option'];
  $vote->value_type = VOTINGAPI_VALUE_TYPE_KEY;
  votingapi_set_vote('decisions', $node->nid, $vote);
}
?>