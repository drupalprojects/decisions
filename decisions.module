<?php

/**
 * @file
 * Modular voting mechanisms, delegatable votes, taxonomy/category influenced controls and weighted voting
 * See http://decisions.gnuvernment.org for more information on the project.
 *
 * Heavily inspired by other Drupal modules, mostly from poll.module, but we adapted it to "drupal forms api".
 * Thanks to everyone for all the that was already written. (...and debugged!)
 */

$MODES_DIR = dirname(__FILE__) . '/modes/';

$decisions_available_modes = array();

if (is_dir($MODES_DIR)) {
  if ($dh = opendir($MODES_DIR)) {
    while (($file = readdir($dh)) !== false) {
      if (preg_match('/^([^\.].*)\.include$/', $file, $matches)) {
        require_once($MODES_DIR . $file);
        $mode = $matches[1];
        if ( function_exists("decisions_$mode_longname") ) {
          $decisions_available_modes[$mode] = call_user_func("decisions_$mode_longname");
        }
        else {
          $decisions_available_modes[$mode] = $mode;
        }
      }
    }
  }
} else {
  watchdog('decisions', "cannot find the modes directory containing decisions modes definitions in $MODES_DIR. This will cause problems.", WATCHDOG_ERROR);
}

/**
 * Implementation of hook_access().
 */
function decisions_access($op, $node) {
  global $user;

  if ($op == 'create') {
    return user_access('create decisions');
  }
  if ($op == 'delete') {
    return user_access('delete decisions');
  }
  if ($op == 'update') {
    /* you can update it if you can create it, provided it is your own... */
    if (user_access('create decisions') && ($user->uid == $node->uid)) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_block().
 */
function decisions_block($op = 'list', $delta = 0, $edit = array()) {
  switch($op) {
    case 'list' :
      $blocks[0]['info'] = t('A decisions block');
      return $blocks;
    case 'view' :
      $blocks["content"] = decisions_block_contents();
      $blocks["subject"] = "decisions";
      return $blocks;
  }
}

/**
 * Content of the block, as returned by decisions_block('view')
 */
function decisions_block_contents() {
  $block = '';
  if ( user_access('view decisions') ) {
    /* get list of decisions and show them */
    if ( user_access('vote on decisions') ) {
      /* add a link to vote on the decision */
    }
  }
  return $block;
}

/**
 * Implementation of hook_delete().
 *
 * TODO: to test
 * TODO: do we remove the votes themselves?
 */
function decisions_delete($node) {
  db_query("DELETE FROM {decisions} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {decisions_options} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {decisions_electoral_list} WHERE nid = %d", $node->nid);
}

/**
 * Implementation of hook_form().
 *
 * This hook displays the form necessary to edit the *node* (ie. not the votes).
 */
function decisions_form($node) {

  /* standard node elements */
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#required' => TRUE,
    '#default_value' => $node->title,
  );
  $form['body'] = array(
    '#type' => 'textarea',
    '#title' => t('Description'),
    '#required' => FALSE,
    '#default_value' => $node->body,
  );

  $form['mode'] = array(
    '#type' => 'select',
    '#title' => t('Decision mode'),
    '#required' => TRUE,
    '#options' => array( 'poll' => t('Poll'), 'runoff' => t('Runoff') ),
    '#default_value' => (isset($node->mode) ? $node->mode : variable_get('mode', 'poll')),
  );

  /* decision-specific elements */
  /* this code is mostly from poll.module */
  if (!isset($node->options)) {
    $node->options = 5;
  }
  // User ticked 'need more choices'.
  if ($_POST['edit']['OptionGroup']['moreoptions'] || !$node->options) {
    if (!$node->options)
        $node->options = 2;
    else
    	$node->options *= 2;
  }

  // Options list
  $form['OptionGroup'] = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#title' => t('Options'),
    '#collapsible' => TRUE,
  );
  for ( $option_number = 1; $option_number <= $node->options; $option_number++ ) {
    $form['OptionGroup']['Option_'.$option_number] = array(
      '#type' => 'textfield',
      '#title' => t('Option %n', array('%n' => $option_number)),
      '#required' => FALSE,
      '#default_value' => $node->option[$option_number],
      '#size' => 50,
      '#maxlength' => 127,
    );
  }

  $form['OptionGroup']['options'] = array(
    '#type' => 'hidden',
    '#value' => $node->options,
  );
  $form['OptionGroup']['moreoptions'] = array(
    '#type' => 'checkbox',
    '#title' => t('Need more options'),
    '#default_value' => FALSE,
    '#description' => t("If the amount of boxes above isn't enough, check this box and click the Preview button below to add some more."),
  );

  return array_merge($form, filter_form($node->format));
}


/**
 * Implementation of hook_help().
 */
function decisions_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Allow people to reproduce and surpass the kinds of decision-making instances that exist in face-to-face meetings.');
    case 'node/add#decisions':
      return t('Submit a new decision to the electoral list.');
  }
}

/**
 * Implementation of hook_load().
 *
 * Load the votes and decision-specific data into the node object.
 */
function decisions_load($node) {
   $decision = db_fetch_object(db_query("SELECT * FROM {decisions} WHERE nid = %d", $node->nid));
   $result = db_query("SELECT optorder, opttext FROM {decisions_options} WHERE nid = %d ORDER BY optorder", $node->nid);
   while ($option = db_fetch_array($result)) {
   	$decision->option[$option['optorder']] = $option['opttext'];
   }
   $decision->options = count($decision->option);
   return $decision;
}

/**
 * Implementation of hook_menu().
 *
 * Just a path for creating new decisions for now, but we could
 * eventually have a 'my decisions' and 'view decisions' kind of
 * page. (TODO)
 */
function decisions_menu($may_cache) {
  global $user;

  $items = array();

  if ($may_cache) {
    $items[] = array('path' => 'node/add/decisions', 'title' => t('decision'),
      'access' => user_access('create decisions'));
    /*
    $items[] = array('path' => 'decisions', 'title' => t('decisions'),
      'callback' => 'decision_page',
      'access' => user_access('view decisions'),
      'type' => MENU_SUGGESTED_ITEM);
    $items[] = array('path' => 'decisions/'. $user->uid, 'title' => t('my decisions'),
      'access' => user_access('create decisions'),
      'type' => MENU_DYNAMIC_ITEM);
    */
  }

  return $items;
}

/**
 * Implementation of hook_node_info().
 */
function decisions_node_info() {
  return array('decisions' => array('name' => t('decision'), 'base' => 'decisions'));
}

/**
 * Implementation of hook_perm().
 */
function decisions_perm() {
  return array('create decisions', 'delete decisions', 'view decisions', 'vote on decisions');
}

/**
 * Implementation of hook_settings().
 *
 * Not configurable yet.
 */
function decisions_settings() {
  $output = '';
  return $output;
}

/**
 * Implementation of hook_update().
 *
 * This is called upon node edition.
 */
function decisions_update($node) {
  db_query("UPDATE {decisions} SET mode = '%s' WHERE nid = %d", $node->mode, $node->nid);
  # XXX: should update decisions here, when it has some parameters
  # XXX: ... but before doing so, the code below must be factored out in a seperate function for usage in decisions_insert()
  db_query('DELETE FROM {decisions_options} WHERE nid = %d', $node->nid);

  foreach ($node->OptionGroup as $key => $option) {
  	$order = str_replace('Option_', '', $key);
	if ($order != $key && $option != '') {
		db_query("INSERT INTO {decisions_options} (nid, opttext, optorder) VALUES (%d, '%s', %d)", $node->nid, $option, intval($order));
	   }
	# ignore entries other than options
  }
}

/**
 * Implementation of hook_insert()
 *
 * This is called upon node creation
 */
function decisions_insert($node) {
  # just create an empty entry for now
  db_query("INSERT INTO {decisions} (nid, mode) VALUES (%d, '%s')", $node->nid, $node->mode);

  # create the electoral list

  # check first if authenticated users have the right to vote, because authenticated users are not added to the users_roles permission, probably for performance reasons
  $result = db_fetch_object(db_query("SELECT count(*) AS hit FROM `permission` JOIN role ON role.rid = permission.rid WHERE perm LIKE '%vote on decisions%' AND role.name = 'authenticated user'"));
  if ($result->hit) {
    # special case: any authenticated user can vote
    # add all current users to electoral list
    db_query("INSERT INTO {decisions_electoral_list} (nid, uid) SELECT '%d', u.uid FROM users u", $node->nid);
  } else {
# all users must not be allowed to vote, add relevant users only
    db_query("INSERT INTO {decisions_electoral_list} (nid, uid) SELECT '%d', u.uid FROM users_roles u, permission p WHERE p.perm LIKE '%view decisions%' AND u.rid = p.rid", $node->nid);
  }

  # insert the options, same sequence than update
  decisions_update($node);
}

/**
 * Implementation of hook_validate().
 *
 * XXX: No validation yet.
 */
function decisions_validate($node) {
  // faut appeler form_set_error si necessaire
}

/**
 * Implementation of hook_view().
 */
function decisions_view(&$node, $teaser = FALSE, $page = FALSE, $block = FALSE) {
  $node = node_prepare($node, $teaser);

  if (votingapi_get_user_votes('decisions', $node->nid)) { // show results only if the user has voted
    $output .= decisions_view_results(&$node, $teaser, $page, $block);
  } else { // otherwise, show the vote form or record vote
    if ($_POST['op'] == t('Vote')) {
      $output .= decisions_vote($node);
    } else {
      $output .= decisions_view_voting($node, $teaser, $page, $block);
    }
  }

  $output .= decisions_view_electoral_list($node, $teaser);

  $node->body .= $output;
  $node->teaser .= $output;

}

function decisions_view_electoral_list($node, $teaser = FALSE) {
  $output = '';
  if ( ! $teaser ) {
    $result = db_query("SELECT COUNT(*) AS voters FROM {decisions_electoral_list} WHERE nid=%d", $node->nid);
    $electoral_list = db_fetch_object($result);

    $output = '<div class="decisions-electoral-list">';
    $output .= t('%v eligible voters are on the list', array('%v' => $electoral_list->voters));
    $output .= '</div>';
  }
  return $output;
}

/**
 * Theme stub for redering the voting form, to allow the chance for
 * themes to make this nicer/different
 */
function theme_decisions_view_voting($form) {
  $output .= '<div class="decisions">';
  $output .= '  <div class="option-form">';
  $output .= '    <div class="options">';
  $output .= form_render($form['option']);
  $output .= '    </div>';
  $output .= form_render($form['nid']);
  $output .= form_render($form['vote']);
  $output .= '  </div>';
  $output .= form_render($form);
  $output .= '</div>';
  return $output;
}

/**
 * View the voting form.
 *
 * This calls a function decisions_vote_$mode, where $mode is defined
 * in the node. If the function does not exist, a watchdog error is
 * raised and the error is reported using drupal_set_message().
 *
 * This also takes care of registering new votes, if the vote button
 * has been pressed.
 */
function decisions_view_voting(&$node, $teaser, $page, $block) {

  $mode = $node->mode;

  if ( function_exists("decisions_view_voting_$mode") ) {
    return call_user_func("decisions_view_voting_$mode", $node, $teaser, $page, $block);
  }
  else {
    _decisions_panic_on_mode($node->mode);
  }
}

/**
 * show results of the vote
 *
 * this calls the appropriate vote results function, depending on the
 * mode. It will call decisions_view_results_$mode, similarly to
 * decisions_view_voting().
 */
function decisions_view_results(&$node, $teaser, $page, $block) {
  $mode = $node->mode;
  if ( function_exists("decisions_view_results_$mode") ) {
    return call_user_func("decisions_view_results_$mode", $node, $teaser, $page, $block);
  } else {
    _decisions_panic_on_mode($node->mode);
  }
}

/**
 * record a vote on the node
 *
 * this calls the appropriate vote recording function, depending on
 * the mode. It will call decisions_vote_$mode, similarly to
 * decisions_view_voting().
 */
function decisions_vote($node) {
  global $user;
  $mode = $node->mode;

  $result = db_query("SELECT COUNT(*) AS eligible FROM {decisions_electoral_list} WHERE nid=%d AND uid=%d", $node->nid, $user->uid);
  $can_vote = db_fetch_object($result);
  if ( $can_vote->eligible ) {
    if ( function_exists("decisions_vote_$mode") ) {
      call_user_func("decisions_vote_$mode", $node);
    } else {
      _decisions_panic_on_mode($mode);
    }
  } else {
    drupal_set_message(t('You are not eligible to this decision.'));
  }
}

/**
 * internal function factored out that just rings lots of bells when
 * we detect an unknown mode
 */
function _decisions_panic_on_mode($mode) {
    watchdog('decisions', t('Unknown decision mode : %mode.', array('%mode' => $mode), WATCHDOG_ERROR));
    drupal_set_message(t('Unknown decision mode : %mode.', array('%mode' => $mode), 'error'));
}

?>