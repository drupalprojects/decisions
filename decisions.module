<?php
// $Id$
/**
 * @file
 * Modular voting mechanisms, delegatable votes, taxonomy/category influenced controls and weighted voting
 * See http://decisions.gnuvernment.org for more information on the project.
 *
 * Heavily inspired by other Drupal modules, mostly from poll.module, but we adapted it to "drupal forms api".
 * Thanks to everyone for all the that was already written. (...and debugged!)
 */


define('DECISIONS_DEFAULT_ELECTORAL_LIST', 0);

/**
 * Implementation of hook_access().
 */
function decisions_access($op, $node) {
  global $user;

  if ($op == 'create') {
    return user_access('create decisions');
  }
  if ($op == 'delete') {
    return user_access('delete decisions');
  }
  if ($op == 'update') {
    /* you can update it if you can create it, provided it is your own... */
    if (user_access('create decisions') && ($user->uid == $node->uid)) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_block().
 */
function decisions_block($op = 'list', $delta = 0, $edit = array()) {
  switch($op) {
    case 'list' :
      $blocks[0]['info'] = t('A decisions block');
      return $blocks;
    case 'view' :
      $blocks["content"] = decisions_block_contents();
      $blocks["subject"] = "decisions";
      return $blocks;
  }
}

/**
 * Content of the block, as returned by decisions_block('view')
 */
function decisions_block_contents() {
  $block = '';
  if ( user_access('view decisions') ) {
    /* get list of decisions and show them */
    if ( user_access('vote on decisions') ) {
      /* add a link to vote on the decision */
    }
  }
  return $block;
}

/**
 * Implementation of hook_cron().
 *
 * Closes decisions that have exceeded their allowed runtime.
 */
function decisions_cron() {
  $result = db_query('SELECT d.nid FROM {decisions} d INNER JOIN {node} n ON d.nid = n.nid WHERE (n.created + d.runtime) < '. time() .' AND d.active = 1 AND d.runtime != 0');
  while ($decision = db_fetch_object($result)) {
    db_query("UPDATE {decisions} SET active = 0 WHERE nid=%d", $decision->nid);
  }
}


/**
 * Implementation of hook_delete().
 *
 */
function decisions_delete($node) {
  db_query("DELETE FROM {decisions} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {decisions_options} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {decisions_electoral_list} WHERE nid = %d", $node->nid);

	// Note: this should be converted to a votingapi method eventually
	db_query("DELETE FROM {votingapi_vote} WHERE content_id = %d", $node->nid);
}

/**
 * Implementation of hook_form().
 *
 * This hook displays the form necessary to edit the *node* (ie. not the votes).
 */
function decisions_form($node) {
	
	$enabled = array(0 => t('Disabled'), 1 => t('Enabled'));
  /* standard node elements */
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#required' => TRUE,
    '#default_value' => $node->title,
  );
  $form['body'] = array(
    '#type' => 'textarea',
    '#title' => t('Description'),
    '#required' => FALSE,
    '#default_value' => $node->body,
  );


	$form['settings'] = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#title' => t('Settings'),
    '#collapsible' => TRUE,
  );

		

	// only show for new decisions (not when editing)
	if (!(isset($node) && $node->nid)) {

  	// to pick a reasonable default, configurable
  	$modes = _decisions_mode_list();

	  $form['settings']['mode'] = array(
			'#type' => 'select',
			'#title' => t('Decision mode'),
			'#required' => TRUE,
			'#options' => _decisions_mode_list(),
			'#default_value' => variable_get('decisions_default_mode', $modes[0]),
  	);

		$form['settings']['uselist'] = array(
			'#type' => 'radios',
			'#title' => t('Set the eligible voters upon creation'),
			'#options' => $enabled,
			'#description' => t('If enabled, a list of eligible voters will be created and only that group will be able to vote in the decision.'),
			'#default_value' => variable_get('decisions_default_electoral_list', DECISIONS_DEFAULT_ELECTORAL_LIST),
		);

		$form['settings']['maxchoices'] = array(
			'#type' => 'textfield',
			'#required' => TRUE,
			'#title' => t('Maximum Choices'),
			'#size' => 5,
			'#maxlength' => 10,
			'#description' => t('The number of options voters may select. Set to 0 for no limit.'),
    	'#default_value' => (isset($node->settings['maxchoices'])?
				$node->settings['maxchoices'] : 0),
		);

	}

	

	$active = array(1 => t('Active'), 0 => t('Closed'));
	$form['settings']['active'] = array(
		'#type' => 'radios',
		'#title' => t('Decision Status'),
		'#options' => $active,
		'#default_value' => (isset($node->active)? $node->active : 1),
		'#description' => t('When a decision is closed users may no longer vote on it.'),
	);

  $_duration = array(0 => t('Unlimited')) + drupal_map_assoc(array(86400, 172800, 345600, 604800, 1209600, 2419200, 4838400, 9676800, 31536000), 'format_interval');

  $form['settings']['runtime'] = array(
		'#type' => 'select',
		'#title' => t('Decision duration'),
		'#default_value' => ($node->runtime? $node->runtime : 0),
		'#options' => $_duration,
		'#description' => t('After this period, the decision will be closed automatically.')
	);


  /* decision-specific elements */
  /* this code is mostly from poll.module */
  if (!isset($node->options)) {
    $node->options = 5;
  }
  // User ticked 'need more choices'.
  if ($_POST['edit']['OptionGroup']['moreoptions'] || !$node->options) {
    if (!$node->options)
        $node->options = 2;
    else
    	$node->options *= 2;
  }

  // Options list
  $form['OptionGroup'] = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#title' => t('Options'),
    '#collapsible' => TRUE,
  );
  for ( $option_number = 1; $option_number <= $node->options; $option_number++ ) {
    $form['OptionGroup']['Option_'.$option_number] = array(
      '#type' => 'textfield',
      '#title' => t('Option %n', array('%n' => $option_number)),
      '#required' => FALSE,
      '#default_value' => $node->option[$option_number],
      '#size' => 50,
      '#maxlength' => 127,
    );
  }

  $form['OptionGroup']['options'] = array(
    '#type' => 'hidden',
    '#value' => $node->options,
  );
  $form['OptionGroup']['moreoptions'] = array(
    '#type' => 'checkbox',
    '#title' => t('Need more options'),
    '#default_value' => FALSE,
    '#description' => t("If the amount of boxes above isn't enough, check this box and click the Preview button below to add some more."),
  );

	$form['format'] = filter_form($node->form);
	return $form;
}


/**
 * Implementation of hook_help().
 */
function decisions_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Allow people to reproduce and surpass the kinds of decision-making instances that exist in face-to-face meetings.');
    case 'node/add#decisions':
      return t('Submit a new decision to the electoral list.');
  }
}

/**
 * Implementation of hook_load().
 *
 * Load the votes and decision-specific data into the node object.
 */
function decisions_load($node) {
   $decision = db_fetch_object(db_query("SELECT * FROM {decisions} WHERE nid = %d", $node->nid));
   $result = db_query("SELECT optorder, opttext FROM {decisions_options} WHERE nid = %d ORDER BY optorder", $node->nid);
   while ($option = db_fetch_array($result)) {
   	$decision->option[$option['optorder']] = $option['opttext'];
   }
   $decision->options = count($decision->option);
   return $decision;
}

/**
 * Implementation of hook_menu().
 *
 * Just a path for creating new decisions for now, but we could
 * eventually have a 'my decisions' and 'view decisions' kind of
 * page. (TODO)
 */
function decisions_menu($may_cache) {
  global $user;

  // load the necessary submodules in here instead of _init() to
  // profit from caching, as recommended by
  // http://drupaldocs.org/api/head/function/hook_init
  _decisions_load_modes();

  $items = array();

  if ($may_cache) {
    $items[] = array('path' => 'node/add/decisions', 'title' => t('decision'),
      'access' => user_access('create decisions'));
    /*
    $items[] = array('path' => 'decisions', 'title' => t('decisions'),
      'callback' => 'decision_page',
      'access' => user_access('view decisions'),
      'type' => MENU_SUGGESTED_ITEM);
    $items[] = array('path' => 'decisions/'. $user->uid, 'title' => t('my decisions'),
      'access' => user_access('create decisions'),
      'type' => MENU_DYNAMIC_ITEM);
    */
  }

  return $items;
}

/**
 * Implementation of hook_node_info().
 */
function decisions_node_info() {
  return array('decisions' => array('name' => t('decision'), 'base' => 'decisions'));
}

/**
 * Implementation of hook_perm().
 */
function decisions_perm() {
  return array('create decisions', 'delete decisions', 'view decisions', 'vote on decisions', 'administer decisions');
}

/**
 * Implementation of hook_settings().
 *
 * Not configurable yet.
 */
function decisions_settings() {
	if (!user_access('administer decisions')) {
		return message_access();
	}

	$enabled = array(0 => t('Disabled'), 1 => t('Enabled'));

	$form['main']['decisions_default_electoral_list'] = array(
		'#type' => 'radios',
		'#title' => t('Use electoral list by default'),
		'#description' => t('Use an electoral list by default for new decisions.'),
		'#default_value' => variable_get('decisions_default_electoral_list', DECISIONS_DEFAULT_ELECTORAL_LIST),
		'#options' => $enabled,
	);

	return $form;
}

/**
 * Implementation of hook_update().
 *
 * This is called upon node edition.
 */
function decisions_update($node) {
  db_query("UPDATE {decisions} SET active=%d, runtime=%d WHERE nid = %d", $node->settings['active'], $node->settings['runtime'], $node->nid);
  # XXX: should update decisions here, when it has some parameters
  # XXX: ... but before doing so, the code below must be factored out in a seperate function for usage in decisions_insert()
  db_query('DELETE FROM {decisions_options} WHERE nid = %d', $node->nid);

  foreach ($node->OptionGroup as $key => $option) {
  	$order = str_replace('Option_', '', $key);
	if ($order != $key && $option != '') {
		db_query("INSERT INTO {decisions_options} (nid, opttext, optorder) VALUES (%d, '%s', %d)", $node->nid, $option, intval($order));
	   }
	# ignore entries other than options
  }
}

/**
 * Implementation of hook_insert()
 *
 * This is called upon node creation
 */
function decisions_insert($node) {
  # just create an empty entry for now
  db_query("INSERT INTO {decisions} (nid, mode, uselist, active, runtime, maxchoices) VALUES (%d, '%s', %d, %d, %d, %d)", $node->nid, $node->settings['mode'], $node->settings['uselist'], $node->settings['active'], $node->settings['runtime'], $node->settings['maxchoices']);

  # create the electoral list if desired

	if ($node->uselist) {

  	# check first if authenticated users have the right to vote, because authenticated users are not added to the users_roles permission, probably for performance reasons
  	$result = db_fetch_object(db_query("SELECT COUNT(*) AS hit FROM {permission} JOIN role ON role.rid = permission.rid WHERE FIND_IN_SET(' vote on decisions', perm) AND role.name = 'authenticated user'"));
  	if ($result->hit) {
    	# special case: any authenticated user can vote
    	# add all current users to electoral list
    	db_query("INSERT INTO {decisions_electoral_list} (nid, uid) SELECT '%d', u.uid FROM users u WHERE u.uid != 0", $node->nid);
  	}
  	else {
			# all users must not be allowed to vote, add relevant users only
    	db_query("INSERT INTO {decisions_electoral_list} (nid, uid) SELECT '%d', u.uid FROM users_roles u, permission p WHERE FIND_IN_SET(' view decisions', p.perm) AND u.rid = p.rid AND u.uid != 0", $node->nid);
  	}
	}

  # insert the options, same sequence than update
  decisions_update($node);
}

/**
 * Implementation of hook_validate().
 *
 * XXX: No validation yet.
 */
function decisions_validate($node) {
  // faut appeler form_set_error si necessaire
}

/**
 * Implementation of hook_view().
 */
function decisions_view(&$node, $teaser = FALSE, $page = FALSE, $block = FALSE) {
  $node = node_prepare($node, $teaser);

  if (!$node->active
		|| votingapi_get_user_votes('decisions', $node->nid)) {
		// show results only if the user has voted or decision is closed
    $output .= decisions_view_results($node, $teaser, $page, $block);
  }
  else { // otherwise, show the vote form or record vote
    $valid = FALSE;
    if ($_POST['op'] == t('Vote')) {
      // decision_vote will return FALSE on error
      $valid = decisions_vote_validate($node);
      if ($valid) {
        drupal_set_message(t("Your vote was registered."));
        decisions_vote($node);
      }
    }
    if (!$valid && decisions_eligible($node)) {
      $output .= decisions_view_voting($node, $teaser, $page, $block);
    }
  }

  // XXX: when and to whom do we show this?
  $output .= decisions_view_electoral_list($node, $teaser);

  $node->body .= $output;
  $node->teaser .= $output;

}

function decisions_view_electoral_list($node, $teaser = FALSE) {
  $output = '';
  if (!$teaser) {
		if ($node->uselist) {
    	$result = db_query("SELECT COUNT(*) AS voters FROM {decisions_electoral_list} WHERE nid=%d", $node->nid);
    	$electoral_list = db_fetch_object($result);
		}
    $result = db_query("SELECT COUNT(DISTINCT uid) AS voters FROM {votingapi_vote} WHERE content_id=%d GROUP BY uid", $node->nid);
    $votes = db_num_rows($result);

    $output = '<div class="decisions-electoral-list">';
		if ($node->uselist) {
    	$output .= ($votes == 1? t('%d out of %v eligible voters has voted.'
					, array('%d' => $votes, '%v' => $electoral_list->voters))
				: t('%d out of %v eligible voters have voted.',
					array('%d' => $votes, '%v' => $electoral_list->voters)));
		}
		else {
			$output .= ($votes == 1? t('%d voter has voted.', array('%d' => $votes))
				: t('%d voters have voted.', array('%d' => $votes)));
		}
    $output .= '</div>';
  }
  return $output;
}

/**
 * Theme stub for redering the voting form, to allow the chance for
 * themes to make this nicer/different
 */
function theme_decisions_view_voting($form) {
  $output .= '<div class="decisions">';
  $output .= '  <div class="option-form">';
  $output .= '    <div class="options">';
  $output .= form_render($form['option']);
  $output .= '    </div>';
  $output .= form_render($form['nid']);
  $output .= form_render($form['vote']);
  $output .= '  </div>';
  $output .= form_render($form);
  $output .= '</div>';
  return $output;
}

/**
 * View the voting form.
 *
 * This calls a function decisions_vote_$mode, where $mode is defined
 * in the node. If the function does not exist, a watchdog error is
 * raised and the error is reported using drupal_set_message().
 *
 * This also takes care of registering new votes, if the vote button
 * has been pressed.
 */
function decisions_view_voting(&$node, $teaser, $page, $block) {

  $mode = $node->mode;

  if ( function_exists("decisions_view_voting_$mode") ) {
    return call_user_func("decisions_view_voting_$mode", $node, $teaser, $page, $block);
  }
  else {
    _decisions_panic_on_mode($node->mode);
  }
}

/**
 * show results of the vote
 *
 * this calls the appropriate vote results function, depending on the
 * mode. It will call decisions_view_results_$mode, similarly to
 * decisions_view_voting().
 */
function decisions_view_results(&$node, $teaser, $page, $block) {
  $mode = $node->mode;
  if ( function_exists("decisions_view_results_$mode") ) {
    return call_user_func("decisions_view_results_$mode", $node, $teaser, $page, $block);
  }
  else {
    _decisions_panic_on_mode($node->mode);
  }
}

/**
 * record a vote on the node
 *
 * this calls the appropriate vote recording function, depending on
 * the mode. It will call decisions_vote_$mode, similarly to
 * decisions_view_voting().
 */
function decisions_vote($node) {
  $mode = $node->mode;

  $ok = FALSE; // error by default
  if ( decisions_eligible($node) ) {
    if ( function_exists("decisions_vote_$mode") ) {
      call_user_func("decisions_vote_$mode", $node);
    }
    else {
      _decisions_panic_on_mode($mode);
    }
  }
  else {
    drupal_set_message(t('You are not eligible to this decision.'));
  }
}

/**
 * validate vote form submission
 *
 * this will call a hook named decisions_vote_validate_$mode and
 * return its value. hooks should check $POST to see if the vote data
 * submitted is valid and use form_set_error() if the form has invalid
 * data.
 *
 * @returns boolean true if form has valid data or if no hook is
 * defined in mode
 */
function decisions_vote_validate($node) {
  $mode = $node->mode;
  if (function_exists("decisions_vote_validate_$mode") ) {
    return call_user_func("decisions_vote_validate_$mode", $node);
  }
  return TRUE;
}

/**
 * check if user is eligible to this decision
 */
function decisions_eligible($node, $uid = NULL) {
  global $user;
  if (!isset($uid)) {
    $uid = $user->uid;
  }

	if ($node->uselist) {
  	$can_vote = db_fetch_object(db_query("SELECT COUNT(*) AS eligible FROM {decisions_electoral_list} WHERE nid=%d AND uid=%d", $node->nid, $uid));
	}
	else {
		return user_access('vote on decisions');
	}
  return $can_vote->eligible;
}

/**
 * internal function factored out that just rings lots of bells when
 * we detect an unknown mode
 */
function _decisions_panic_on_mode($mode) {
    watchdog('decisions', t('Unknown decision mode : %mode.', array('%mode' => $mode), WATCHDOG_ERROR));
    drupal_set_message(t('Unknown decision mode : %mode.', array('%mode' => $mode), 'error'));
}

/**
 * internal function to load the available modes.
 *
 * this scans the modes subdirectory to find mode.inc files, where
 * mode is considered to be the mode name. found files are loaded and
 * added to the mode list.
 *
 * @uses _decisions_mode_list()
 * @uses file_scan_directory()
 */
function _decisions_load_modes() {
  global $_decisions_modes;

  foreach (file_scan_directory(dirname(__FILE__) . '/modes/', '^([^\.].*)\.inc$', array('.', '..', 'CVS'), 0, FALSE) as $file) {
          require_once($file->filename);
          $mode = $file->name;
          if ( function_exists("decisions_${mode}_longname") ) {
            _decisions_mode_list($mode, call_user_func("decisions_${mode}_longname"));
          }
          else {
            drupal_set_message("decisions_${mode}_longname ??");
            _decisions_mode_list($mode);
          }

  }
}

/**
 * list or set the known modes
 *
 * @param string $mode set/change the given mode
 * @param string $longname optional. set a longname different than the mode name
 *
 * @returns array the module list as a mode => longname associative array
 */
function _decisions_mode_list($mode = NULL, $longname = NULL) {
  static $_decisions_modes = array();

  if (!is_null($mode)) {
    if (is_null($longname)) {
      $longname = $mode;
    }
    $_decisions_modes[$mode] = $longname;
  }
  return $_decisions_modes;
}

?>
