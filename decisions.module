<?php

/**
 * @file
 *
 * Modular voting mechanisms, delegatable votes, taxonomy/category
 * influenced controls and weighted voting
 *
 * See http://decisions.gnuvernment.org for more information on the project.
 *
 * Heavily inspired by other Drupal modules, mostly from poll.module,
 * but we adapted it to "drupal forms api".  Thanks to everyone for
 * all the that was already written. (...and debugged!)
 *
 * $Id$
 */

define('DECISIONS_DEFAULT_ELECTORAL_LIST', 0);
// always, aftervote, or afterclose
define('DECISIONS_DEFAULT_VIEW_RESULTS', 'aftervote');
define('DECISIONS_RUNTIME_INFINITY', 0);


/*****************/
/* API functions */
/*****************/

/**
 * Implementation of hook_access().
 */
function decisions_access($op, $node, $account) {
  if ($op == 'create') {
    return user_access('create decisions', $account);
  }
  if ($op == 'delete') {
    return user_access('delete decisions', $account);
  }
  if ($op == 'update') {
    /* you can update it if you can create it, provided it is your own... */
    if (user_access('create decisions', $account) && ($account->uid == $node->uid)) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_block().
 */
function decisions_block($op = 'list', $delta = 'mostrecent', $edit = array()){
  if ($op == 'list') {
    $block = array('mostrecent' => array('info' => t('Decisions - Newest')));
  }
  elseif ($op == 'view') {
    if (user_access('view decisions')) {
      switch ($delta) {
      case 'mostrecent':
        $block = array('subject' => t('Decisions - Newest'), 'content' => _decisions_block_mostrecent());
        break;
      default:
        $block = array();
        break;
      }
    }
  }
  return $block;
}

/**
 * Implementation of hook_cron().
 *
 * Closes decisions that have exceeded their allowed runtime.
 */
function decisions_cron() {
  $result = db_query('SELECT d.nid FROM {decisions} d INNER JOIN {node} n ON d.nid = n.nid WHERE (n.created + d.runtime) < '. time() .' AND d.active = 1 AND d.runtime != 0');
  while ($decision = db_fetch_object($result)) {
    db_query("UPDATE {decisions} SET active = 0 WHERE nid=%d", $decision->nid);
  }
}

/**
 * Implementation of hook_delete().
 *
 */
function decisions_delete($node) {
  db_query("DELETE FROM {decisions} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {decisions_choices} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {decisions_electoral_list} WHERE nid = %d", $node->nid);

  // Note: this should be converted to a votingapi method eventually
  db_query("DELETE FROM {votingapi_vote} WHERE content_id = %d", $node->nid);
}

/**
 * Implementation of votingapi_hook_calculate()
 */
function decisions_votingapi_calculate(&$cache, $votes, $content_type, $content_id) {
  if ($content_type == 'decisions') {
    $node = node_load($content_id);
    $mode = _decisions_get_mode($node);
    $function = "{$mode}_decisions_votingapi_calculate";
    if (function_exists($function)) {
      return call_user_func($function, $node, $cache, $votes, $content_type, $content_id);
    }
  }
}

/**
 * Implementation of hook_form().
 *
 * This hook displays the form necessary to edit the *node* (ie. not the votes).
 */
function decisions_form(&$node, &$form_state) {
  $mode = _decisions_get_mode($node);
  $form_values = $form_state['values']; # adapt to D6 FormsAPI

  $form['title'] = array(
                         '#type' => 'textfield',
                         '#title' => ucfirst($mode) . ' ' . t('Question'),
                         '#required' => TRUE,
                         '#default_value' => $node->title,
                         );

  $form['body'] = array(
                        '#type' => 'textarea',
                        '#title' => t('Description'),
                        '#required' => FALSE,
                        '#default_value' => $node->body,
                        );

  if (isset($form_values['choices'])) {
    $choices = $form_values['choices'];
  } else {
    $choices = max(2, isset($node->choice) && count($node->choice) ? count($node->choice) : 5);
  }
  
  $form['choice']['choices'] = array(
                                     '#type' => 'hidden',
                                     '#default_value' => $choices
                                     );
  
  $form['choice']['morechoices'] = array(
                                         '#type' => 'checkbox',
                                         '#title' => t('Need more choices'),
                                         '#default_value' => 0,
                                         '#return_value' => 1,
                                         '#prefix' => '<div id="morechoices">',
                                         '#suffix' => '</div>',
                                         '#description' => t("If the amount of boxes above isn't enough, check this box and click the Preview button below to add some more."),
                                         '#weight' => 1
                                         );
  
  $form['choice'] = form_builder($node->type . '_node_form', $form['choice'], $form_state);
  
  // Decisions choices
  $form['choice'] += array(
                           '#type' => 'fieldset',
                           '#title' => t('Decision choices'),
                           '#collapsible' => TRUE,
                           '#prefix' => '<div class="poll-form">',
                           '#suffix' => '</div>', '#tree' => TRUE,
                           '#weight' => 1,
                           );
    
  for ($a = 1; $a <= $choices; $a++) {
    $form['choice'][$a]['label'] = array(
                                          '#type' => 'textfield',
                                          '#title' => t('Choice @n', array('@n' => $a)),
                                          '#default_value' => (isset($node->choice) ? $node->choice[$a]['label'] : NULL),
                                          '#attributes' => array('class' => 'choices'),
                                          );
  }

  $form['settings'] = array(
                            '#type' => 'fieldset',
                            '#tree' => TRUE,
                            '#title' => t('Decision settings'),
                            '#collapsible' => TRUE,
                            '#collapsed' => TRUE,
                            '#weight' => 2,
                            );

  $maxChoiceList = array();
  for ($i = 0; $i <= $choices; $i++) {
    $maxChoiceList[$i] = ($i == 0? 'No limit' : $i);
  }

  $form['settings']['maxchoices'] = array(
                                          '#type' => 'select',
                                          '#title' => t('Maximum Choices'),
                                          '#default_value' => (isset($node->maxchoices)? $node->maxchoices : 0),
                                          '#options' => $maxChoiceList,
                                          '#description' => t('Limits the total number of choices voters may select.'),
                                          );

  $algs = decisions_algorithms($mode);
  
  foreach ($algs as $alg) {
    $voting_algorithms[$alg] = ucwords($alg);
  }

  $defaultalg = ($form_values['edit']['settings']['algorithm'] ?
                   $form_values['edit']['settings']['algorithm'] : 
                 (isset($node->algorithm) ? $node->algorithm : 
                     (isset($algs[0]) ? $algs[0] : '')));

  if (count($voting_algorithms) > 1) {
    $form['settings']['algorithm'] = array(
                                         '#type' => 'select',
                                         '#title' => t('Algorithm'),
                                         '#options' => $voting_algorithms,
                                         '#default_value' => $defaultalg,
                                         '#description' => 'Voting algorithm to use to calculate the winner.',
                                         );
  } else {
    $form['settings']['algorithm'] = array('#type' => 'hidden', '#value' => $defaultalg);
  }

  $active = array(1 => t('Active'), 0 => t('Closed'));
  $form['settings']['active'] = array(
                                      '#type' => 'radios',
                                      '#title' => t('Decision Status'),
                                      '#options' => $active,
                                      '#default_value' => (isset($node->active)? $node->active : 1),
                                      '#description' => t('When a decision is closed users may no longer vote on it.'),
                                      );

  $enabled = array(0 => t('Disabled'), 1 => t('Enabled'));
  $form['settings']['uselist'] = array(
                                       '#type' => 'checkbox',
                                       '#title' => t('Restrict voting to electoral list'),
                                       '#description' => t('If enabled, a list of eligible voters will be created and only that group will be able to vote in the decision.'),
                                       '#default_value' => isset($node->uselist)? $node->uselist : variable_get('decisions_default_electoral_list', DECISIONS_DEFAULT_ELECTORAL_LIST),
                                       '#options' => $enabled,
                                       );

  $form['settings']['showvotes'] = array(
                                         '#type' => 'checkbox',
                                         '#title' => t('Show individual votes'),
                                         '#description' => t('Users with the appropriate permissions will be able to see how each person voted.'),
                                         '#default_value' => isset($node->showvotes)? $node->showvotes : 1,
                                         '#options' => $enabled,
                                         );

  $form['settings']['date'] = array(
    '#type' => 'fieldset',
    '#title' => t('Date options'),
    '#collapsed' => TRUE,
    '#collapsible' => TRUE,
  );
  
  $startdate = !is_null($node->startdate) ? $node->startdate : time();
  $runtime = !is_null($node->runtime) ? $node->runtime : variable_get('decisions_default_runtime', 24 * 60 * 60);
  if ($runtime == DECISIONS_RUNTIME_INFINITY) {
    $enddate = $startdate; // by default
  } else {
    $enddate = $startdate + $runtime;
  }
  
  $form['settings']['date']['startdate'] = array(
    '#type' => 'fieldset',
    '#collapsed' => FALSE,
    '#description' => t('Opening date')
  );  
  $form['settings']['date']['startdate']['date'] = _decisions_form_date($startdate);
  
  $form['settings']['date']['noenddate'] = array(
    '#type' => 'checkbox',
    '#title' => t('No closing date'),
    '#default_value' => ($runtime == DECISIONS_RUNTIME_INFINITY),
    '#description' => t('Check this box if you do not want the vote to close on a specific date.'),
  );

  $form['settings']['date']['enddate'] = array(
    '#type' => 'fieldset',
    '#collapsed' => FALSE,
    '#description' => t('Closing date')
  );  
  $form['settings']['date']['enddate']['date'] = _decisions_form_date($enddate);

  
  $form['settings']['quorum'] = array(
                            '#type' => 'fieldset',
                            '#tree' => TRUE,
                            '#title' => t('Quorum'),
                            '#collapsible' => TRUE,
                            '#collapsed' => TRUE,
                            '#weight' => 2,
                            '#description' => t('These settings allow for a decision to be valid only if a certain number of eligible voters have cast their ballot. It can be configured both with an absolute number and a percentage of eligible voters. For example, a common setting is "50% + 1", which would be expressed as "@percent: 50" and "@number: 1".', array('@percent' => t('Percentage (%)'), '@number' => t('Number'))),
                            );

  $form['settings']['quorum']['quorum_abs'] = array(
                                       '#type' => 'textfield',
                                       '#size' => 10,
                                       '#title' => t('Number'),
                                       '#default_value' => ($node->quorum_abs? $node->quorum_abs : 0),
                                       '#required' => TRUE,
                                       '#description' => t('Minimum number of voters required to cast their ballot for this decision to be valid.')
                                       );

  $form['settings']['quorum']['quorum_percent'] = array(
                                       '#type' => 'textfield',
                                       '#size' => 10,
                                       '#title' => t('Percentage (%)'),
                                       '#default_value' => ($node->quorum_percent? $node->quorum_percent : 0),
                                       '#required' => TRUE,
                                       '#description' => t('Minimum numbers of voters required for this decision to be valid, expressed as a percentage of the eligible voters (rounded up).'),
                                       '#weight' => -1,
                                       );


  $form['format'] = filter_form($node->form);
  return $form;
}

/**
 * Implementation of hook_form_alter()
 *
 * This is the implementation of the "More choices" option
 */
function decisions_form_alter(&$form, $form_state, $form_id) {
  if (preg_match('/^decisions_.*_node_form$/', $form_id)) {
    if ($form['choice']['morechoices']['#return_value']) { # XXX: not sure this is right
      $form['#rebuild'] = TRUE;
      $choices = $form['choice']['choices']['#value'];
      for ($a = $choices+1; $a <= $choices*2; $a++) {
        $form['choice'][$a]['label'] = array(
                                             '#type' => 'textfield',
                                             '#title' => t('Choice @n', array('@n' => $a)),
                                             '#default_value' => (isset($node->choice) ? $node->choice[$a]['label'] : NULL),
                                             '#attributes' => array('class' => 'choices'),
        );
      }
    }
  }
}

/**
 * Implementation of hook_help().
 */
function decisions_help($path, $arg) {
  switch ($path) {
  case 'admin/modules#description':
    return t('Allow people to reproduce and surpass the kinds of decision-making instances that exist in face-to-face meetings.');
  }
}

/**
 * Implementation of hook_load().
 *
 * Load the votes and decision-specific data into the node object.
 */
function decisions_load($node) {
  $decision = db_fetch_object(db_query("SELECT * FROM {decisions} WHERE nid = %d", $node->nid));
  $result = db_query("SELECT vote_offset, label FROM {decisions_choices} WHERE nid = %d ORDER BY vote_offset", $node->nid);
  while ($choice = db_fetch_array($result)) {
    $decision->choice[$choice['vote_offset']] = $choice;
  }
  $decision->choices = count($decision->choice);

  // See if user has voted
  $criteria = votingapi_current_user_identifier();
  $criteria['content_type'] = 'decisions';
  $criteria['content_id'] = $node->nid;
  $decision->voted = count(votingapi_select_votes($criteria)) > 0;

  return $decision;
}

function decisions_init() {
  // extension files are included here in order to lighten Drupal bootstrap
  module_load_include('inc', 'decisions', 'decisions_datetime');
}

/**
 * Implementation of hook_menu().
 *
 * Just a path for creating new decisions for now, but we could
 * eventually have a 'my decisions' and 'view decisions' kind of
 * page. (TODO)
 */
function decisions_menu() {
  $items['admin/settings/decisions'] = array(
    'title' => 'Configure decisions',
    'description' => 'Configure Decisions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('decisions_admin'),
    'access arguments' => array('administer decisions'),
    'type' => MENU_NORMAL_ITEM,
   );

  $items['node/%node/votes'] = array(
                           'title' => 'votes',
                           'page callback' => 'decisions_votes_tab',
                           'page arguments' => array(1),
                           'access callback' => '_decisions_votes_access',
                           'access arguments' => array(1, 'inspect all votes'),
                           'weight' => 3,
                           'type' => MENU_LOCAL_TASK
                           );
  
  $items['node/%node/electoral_list'] = array(
                           'title' => 'Electoral list',
                           'page callback' => 'decisions_electoral_list_tab',
                           'page arguments' => array(1),
                           'access callback' => '_decisions_electoral_list_access',
                           'access arguments' => array(1, 'view electoral list'),
                           'weight' => 3,
                           'type' => MENU_LOCAL_TASK
                           );
  // Allow voters to be removed
  $items['node/%node/remove'] = array(
                           'page callback' => 'decisions_electoral_list_remove_voter',
                           'page arguments' => array(1),
                           'access callback' => '_decisions_electoral_list_access',
                           'access arguments' => array(1, 'remove voters'),
                           'weight' => 3,
                           'type' => MENU_CALLBACK,
                           );
    
  return $items;
}

/**
 * Implementation of hook_perm().
 */
function decisions_perm() {
  return array('create decisions', 'delete decisions', 'view decisions', 'vote on decisions', 'cancel own vote', 'administer decisions', 'inspect all votes', 'view electoral list', 'remove voters');
}

/**
 * Implementation of the admin_settings hook
 */
function decisions_admin() {

  $enabled = array(0 => t('Disabled'), 1 => t('Enabled'));

  $form['main']['decisions_default_electoral_list'] = array(
                                                            '#type' => 'radios',
                                                            '#title' => t('Use electoral list by default'),
                                                            '#description' => t('Use an electoral list by default for new decisions.'),
                                                            '#default_value' => variable_get('decisions_default_electoral_list', DECISIONS_DEFAULT_ELECTORAL_LIST),
                                                            '#options' => $enabled,
                                                            );

  $view_results = array(
                        'always' => t('Always'),
                        'aftervote' => t('After user has voted'),
                        'afterclose' => t('After voting has closed'),
                        );

  $form['main']['decisions_view_results'] = array(
                                                  '#type' => 'radios',
                                                  '#title' => t('When should results be displayed'),
                                                  '#description' => t('Determines when users may view the results of the decision.'),
                                                  '#default_value' => variable_get('decisions_view_results', DECISIONS_DEFAULT_VIEW_RESULTS),
                                                  '#options' => $view_results,
                                                  );

  return system_settings_form($form);
}

function decisions_cancel_form($form_state, $nid) {
  $form['node'] = array('#type' => 'hidden', '#value' => $nid);
  $form['submit'] = array('#type' => 'submit', '#value' => t('Cancel your vote'));
  return $form; 
}

function decisions_cancel_form_submit($form, &$form_state) {
  decisions_cancel($form_state['values']['node']);
}

/**
 * Implementation of hook_update().
 *
 * This is called upon node edition.
 */
function decisions_update($node) {
  // Compute startdate and runtime.
  $startdate = _decisions_translate_form_date($node->settings['date']['startdate']['date']);
  if ($node->settings['date']['noenddate']) {
    $runtime = DECISIONS_RUNTIME_INFINITY;
  } else {
    $enddate =  _decisions_translate_form_date($node->settings['date']['enddate']['date']);
    if ($enddate < $startdate) {
      form_set_error('enddate', t('The specified close date is less than the opening date, setting it to the same for now.'));
      $enddate = $startdate;
    }
    $runtime = $enddate - $startdate;
  }
    
  db_query("UPDATE {decisions} SET quorum_abs=%d, quorum_percent=%f, active=%d, runtime=%d, maxchoices=%d, algorithm='%s', uselist=%d, showvotes=%d, startdate=%d WHERE nid = %d", $node->settings['quorum_abs'], $node->settings['quorum_percent'], $node->settings['active'], $runtime, $node->settings['maxchoices'], $node->settings['algorithm'], $node->settings['uselist'], $node->settings['showvotes'], $startdate, $node->nid);
  // XXX: should update decisions here, when it has some parameters
  // XXX: ... but before doing so, the code below must be factored out in a seperate function for usage in decisions_insert()
  db_query('DELETE FROM {decisions_choices} WHERE nid = %d', $node->nid);

  // Start at one rather than 0 due to Drupal FormAPI
  $i = 1;
  foreach ($node->choice as $key => $choice) {
    // XXX: this is ugly. For some reason, formapi was passing a value
    // at the end of the array in which $choice = 0 *and*
    // isset($choice['label']) returns true. so we use this whole ugly
    // string.
    if (is_array($choice) && array_key_exists('label', $choice) && $choice['label'] != '') {
      db_query("INSERT INTO {decisions_choices} (nid, label, vote_offset) VALUES (%d, '%s', %d)", $node->nid, $choice['label'], $i++);
    }
  }
}

function _decisions_get_mode($node) {
  if ($node->type) {
    $types = explode('_', $node->type, 2);
    return $types[1];
  }
  else {
    drupal_set_message('No type specified for node: ' . $node->nid, 'error');
    return '';
  }
}

/**
 * Implementation of hook_insert()
 *
 * This is called upon node creation
 */
function decisions_insert($node) {
  // Compute startdate and runtime.
  $startdate = _decisions_translate_form_date($node->settings['date']['startdate']['date']);
  if ($node->settings['date']['noenddate']) {
    $runtime = DECISIONS_RUNTIME_INFINITY;
  } else {
    $enddate =  _decisions_translate_form_date($node->settings['date']['enddate']['date']);
    if ($enddate < $startdate) {
      form_set_error('enddate', t('The specified close date is less than the opening date, setting it to the same for now.'));
      $enddate = $startdate;
    }
    $runtime = $enddate - $startdate;
  }
  
  // just create an empty entry for now
  $mode = _decisions_get_mode($node);

  $algs = decisions_algorithms($mode);
  db_query("INSERT INTO {decisions} (nid, mode, quorum_abs, quorum_percent, uselist, active, runtime, maxchoices, algorithm, startdate) VALUES (%d, '%s', %d, %f, %d, %d, %d, %d, '%s', %d)", $node->nid, $mode, $node->settings['quorum_abs'], $node->settings['quorum_percent'], $node->settings['uselist'], $node->settings['active'], $node->settings['runtime'], $node->settings['maxchoices'], $algs[0], $startdate);

  // create the electoral list if desired

  if ($node->settings['uselist']) {
    // check first if authenticated users have the right to vote, because authenticated users are not added to the users_roles permission, probably for performance reasons
    $result = db_fetch_object(db_query("SELECT COUNT(*) AS hit FROM {permission} JOIN role ON role.rid = permission.rid WHERE FIND_IN_SET(' vote on decisions', perm) AND role.name = 'authenticated user'"));
    if ($result->hit) {
      // special case: any authenticated user can vote
      // add all current users to electoral list
      db_query("INSERT INTO {decisions_electoral_list} (nid, uid) SELECT '%d', u.uid FROM users u WHERE u.uid != 0", $node->nid);
    }
    else {
      // all users must not be allowed to vote, add relevant users only
      db_query("INSERT INTO {decisions_electoral_list} (nid, uid) SELECT '%d', u.uid FROM users_roles u, permission p WHERE FIND_IN_SET(' view decisions', p.perm) AND u.rid = p.rid AND u.uid != 0", $node->nid);
    }
  }

  // insert the choices, same sequence than update
  decisions_update($node);
}

/**
 * Implementation of hook_validate().
 *
 * XXX: No validation yet.
 */
function decisions_validate(&$node) {
  // Use form_set_error for any errors
  $node->choice = array_values($node->choice);

  // Start keys at 1 rather than 0
  array_unshift($node->choice, '');
  unset($node->choice[0]);

  // Check for at least two choices
  $realchoices = 0;
  foreach ($node->choice as $i => $choice) {
    if ($choice['label'] != '') {
      $realchoices++;
    }
  }

  if ($realchoices < 2) {
    form_set_error("choice][$realchoices][label", t('You must fill in at least two choices.'));
  }
}

function decisions_submit(&$node) {
  $node->choice = array_values($node->choice);
  // Start keys at 1 rather than 0
  array_unshift($node->choice, '');
  unset($node->choice[0]);
}

/**
 * Implementation of hook_view().
 */
function decisions_view(&$node, $teaser = FALSE, $page = FALSE) {
  $mode = _decisions_get_mode($node);

  // Since we have a body (the decision's description), we need to
  // include that in the $node->content array, too.
  $node = node_prepare($node, $teaser);
  $node->content['body']['#weight'] = -1;

    // print status messages
    $status_messages = "";
    if (!_decisions_meets_quorum($node)) {
      $status_messages .= theme_decisions_status(t("This decision is not valid. You will not be able to see it until the quorum is met. The quorum is set at @quorum.", array('@quorum' => _decisions_get_quorum($node))));
    }
    if (!$node->active) {
      $status_messages .= theme_decisions_status(t("This decision is currently closed."));
    } else {
      $time = time();
      if ($time < $node->startdate) {
        $status_messages .= theme_decisions_status(t("This decision is not yet opened."));
      } else if ($node->runtime != DECISIONS_RUNTIME_INFINITY && $time >= $node->startdate + $node->runtime) {
        $status_messages .= theme_decisions_status(t("This decision is now closed."));
      }
    }
    $node->content['decisions']['status']['#value'] = $status_messages;
    
    if (arg(2) != 'results' && _decisions_can_vote($node)) {
      // User hasn't voted and we're not on the results tab
      $node->content['decisions']['form']['#value'] = drupal_get_form('decisions_voting_form', $node, $teaser, $page);
      $node->content['decisions']['list']['#value'] = theme_decisions_view_header($node, $teaser);
    }
    elseif (_decisions_can_view_results($node)) {
      // show results only if the user has voted or decision is closed
      $node->content['decisions']['results']['#value'] = decisions_view_results($node, $teaser, $page);
      $node->content['decisions']['list']['#value'] = theme_decisions_view_header($node, $teaser);
    }
    if (isset($node->voted) && $node->voted && user_access('cancel own vote') && $node->active) {
      $node->content['decisions']['cancel']['#value'] = drupal_get_form('decisions_cancel_form', $node->nid);
      $node->content['decisions']['cancel']['#weight'] = 10;
    }

  return $node;
}


/*******************/
/* Theme functions */
/*******************/

function decisions_theme() {
  return array(
    'decisions_view_header' => array('arguments' => array('node' => NULL, 'teaser' => FALSE)),
    'decisions_view_voting' => array('arguments' => array('form' => NULL)),
    'decisions_bar' => array('arguments' => array('title' => NULL, 'percentage' => NULL, 'votes' => NULL)),
    'decisions_status' => array('arguments' => array('message' => NULL))
    );
}

/**
 * Theme stub for rendering ecisions header (contains dates and quorum informations).
 */
function theme_decisions_view_header($node, $teaser = FALSE) {

  $output = '<div class="decisions-header">';

  // dates
  $output .= '<div class="decisions-dates">';
  $output .= theme_item_list(
              array(
                 t('Current date: @date', array('@date' => format_date(time()))),
                 t('Opening date: @date', array('@date' => format_date($node->startdate))),
                 ($node->runtime == DECISIONS_RUNTIME_INFINITY ? 
                   t('No closing date.') :
                   t('Closing date: @date', array('@date' => format_date($node->startdate + $node->runtime))))));
  $output .= '</div>';

  // votes
  $num_eligible_voters = _decisions_count_eligible($node);
  $num_votes = 0;
  if ($result = db_fetch_object(db_query("SELECT COUNT(DISTINCT uid) AS voters FROM {votingapi_vote} WHERE content_id=%d GROUP BY uid", $node->nid))) {
    $num_votes = $result->voters;
  }
  $output .= '<div class="decisions-votes">';
  $output .= t('Total votes: @num-votes (out of @num-voters eligible @voters)',
               array(
                 '@num-votes' => $num_votes,
                 '@num-voters' => $num_eligible_voters,
                 '@voters' => format_plural($num_eligible_voters, 'voter', 'voters')
               )
              );
  $output .= '</div>';

  // quorum
  $quorum = _decisions_get_quorum($node);
  if ($quorum > 0) {
    $output .= '<div class="decisions-quorum">';
    $output .= t('Quorum: @d', array('@d' => $quorum));
    $output .= '</div>';
  }
    
  $output .= '</div>';
  return $output;
}

/**
 * Theme stub for redering the voting form, to allow the chance for
 * themes to make this nicer/different
 */
function theme_decisions_view_voting($form) {
  
  $render = 'drupal_render';
  if (!function_exists($render)) {
    $render = 'form_render';
  }
  $output .= '<div class="decisions">';
  $output .= '  <div class="choice-form">';
  $output .= '    <div class="choices">';
  $output .= $render($form['choice']);
  $output .= '    </div>';
  $output .= $render($form['nid']);
  $output .= $render($form['vote']);
  $output .= '  </div>';
  $output .= $render($form);
  $output .= '</div>';
  return $output;
}

/**
 * Theme stub for a decisions bar.
 */
function theme_decisions_bar($title, $percentage, $votes) {
  $output = '<div class="text">'. $title .'</div>';
  $output .= '<div class="bar"><div style="width: '. $percentage .'%;" class="foreground"></div></div>';
  $output .= '<div class="percent">'. $percentage .'% ('. $votes .')</div>';
   return $output;
}
 
/**
 * Outputs a status line.
 */
function theme_decisions_status($message) {
    return '<div class="error">' . $message . '</div>';
}


/****************************/
/* Electoral list functions */
/****************************/

/**
 * Creates the form for the electoral list.
 */
function decisions_electoral_list_form($form_state, $nid) {
  $form = array();
  $form['electoral_list'] = array(
                                  '#type' => 'fieldset',
                                  '#tree' => TRUE,
                                  '#title' => t('Administer electoral list'),
                                  '#collapsible' => TRUE,
                                  '#weight' => 2,
                                  '#collapsed' => TRUE,
                                  );

  $form['electoral_list']['add_user'] = array(
                                              '#type' => 'textfield',
                                              '#title' => t('Add user'),
                                              '#size' => 40,
                                              '#autocomplete_path' => 'user/autocomplete',
                                              '#description' => t('Add an individual user to the electoral list'),
                                              );

  $form['electoral_list']['submit'] = array(
                                            '#type' => 'submit',
                                            '#value' => t('Modify electoral list'),
                                            );

  $form['electoral_list']['reset'] = array(
                                           '#type' => 'button',
                                           '#value' => t('Reset electoral list'),
                                           );

  $form['nid'] = array('#type' => 'hidden', '#value' => $nid);
  return $form;        

}

/**
 * Outputs the electoral list tab.
 */
function decisions_electoral_list_tab() {
  if ($node = menu_get_object()) {
    $output = "";
    if (!$node->uselist) {
      drupal_not_found();
      return;
    }
    drupal_set_title(check_plain($node->title));
    if (user_access('administer decisions')) {
      $form['electoral_list'] = array(
                                      '#type' => 'fieldset',
                                      '#tree' => TRUE,
                                      '#title' => t('Administer electoral list'),
                                      '#collapsible' => TRUE,
                                      '#weight' => 2,
                                      '#collapsed' => TRUE,
                                      );
  	 
      $form['electoral_list']['add_user'] = array(
                                                  '#type' => 'textfield',
                                                  '#title' => t('Add user'),
                                                  '#size' => 40,
                                                  '#autocomplete_path' => 'user/autocomplete',
                                                  '#description' => t('Add an individual user to the electoral list'),
                                                  );
  	 
      $form['electoral_list']['submit'] = array(
                                                '#type' => 'submit',
                                                '#value' => t('Modify electoral list'),
                                                );
  	 
      $form['electoral_list']['reset'] = array(
                                               '#type' => 'button',
                                               '#value' => t('Reset electoral list'),
                                               );
  	 
      $form['nid'] = array('#type' => 'hidden', '#value' => $node->nid);
      $output .= drupal_get_form('decisions_electoral_list_form', $node->nid);
    }
    $output .= t('This table lists all the eligible voters for this Decision.');

    $header[] = array('data' => t('Voter'), 'field' => 'u.name');

    $result = pager_query("SELECT u.uid, u.name FROM {decisions_electoral_list} el LEFT JOIN {users} u ON el.uid = u.uid WHERE el.nid = %d" . tablesort_sql($header), 20, 0, NULL, $node->nid);
    $eligible_voters = array();
    while ($voter = db_fetch_object($result)) {
      $temp = array(theme('username', $voter));
      
      if (user_access('administer decisions')) {
        $temp[] = l(t('remove'), 'node/'. $node->nid .'/remove/' . $voter->uid);
      }
      
      $eligible_voters[] = $temp;
    }
    $output .= theme('table', $header, $eligible_voters);
    $output .= theme('pager', NULL, 20, 0);
    print theme('page', $output);
  }
  else {
    drupal_not_found();
  }
}

/**
 * Remove an individual voter from the electoral list
 */
function decisions_electoral_list_remove_voter() {
  $nid = arg(1);
  $uid = arg(3);
  if ($uid && $node = node_load($nid)) {
    # XXX: useless SELECT call
    $result = db_query('SELECT name FROM {users} WHERE uid=%d', $uid);
    if ($user = db_fetch_object($result)) {
      db_query('DELETE FROM {decisions_electoral_list} WHERE nid=%d AND uid=%d',
               $nid, $uid);
      drupal_set_message(t('%user removed from the electoral list.', array('%user' => $user->name)));
    }
    else {
      drupal_set_message(t('No user found with a uid of %uid.', array('%uid' => $uid)));
    }
  	 
  }
  drupal_goto('node/' . $node->nid . '/electoral_list');
}
  	 
/**
 * Validate changes to the electoral list
 */
function decisions_electoral_list_validate($form, &$form_state) {
  if ($form_state['values']['op'] == t('Reset electoral list')) {
    if (user_access('administer decisions')) {
      db_query('DELETE FROM {decisions_electoral_list} WHERE nid=%d', $form_state['values']['nid']);
      drupal_set_message(t('Electoral list cleared.'));
      return;
    }
  }
  $add_user = $form_state['values']['electoral_list']['add_user'];
  if ($add_user) {
    // Check that the user exists
    if (db_fetch_object(db_query('SELECT uid FROM {users} WHERE name="%s"', $add_user))) {
      form_set_error('electoral_list][add_user', t('User %user does not exist.', array('%user' => $add_user)));
      return FALSE;
    }
  }
}
  	 
/**
 * Submit changes to the electoral list
 */
function decisions_electoral_list_form_submit($form, &$form_state) {
  $add_user = $form_state['values']['electoral_list']['add_user'];
  $nid = $form_state['values']['nid'];
  if ($add_user) {
    db_query('REPLACE INTO {decisions_electoral_list} (nid, uid) SELECT "%d", u.uid FROM users u WHERE u.name = "%s"', $nid, $add_user);
    drupal_set_message(t('%user added to electoral list.', array('%user' => $add_user)));
    drupal_goto('node/' . $nid . '/electoral_list');
  } else {
    drupal_not_found();
  }
}


/***********************************/
/* Decision-mode related functions */
/***********************************/

/**
 * Show results of the vote.
 *
 * This calls the appropriate vote results function, depending on the
 * mode. It will call the decisions_view_results_$mode hook.
 */
function decisions_view_results(&$node, $teaser, $page) {
  $mode = _decisions_get_mode($node);
  $function = "{$mode}_decisions_view_results";
  if (function_exists($function)) {
    return call_user_func($function, $node, $teaser, $page);
  }
  else {
    _decisions_panic_on_mode($mode, __FUNCTION__);
  }
}

/**
 * View the voting form.
 *
 * This calls a function decisions_vote_$mode, where $mode is defined
 * in the node. If the function does not exist, a watchdog error is
 * raised and the error is reported using drupal_set_message().
 *
 * This also takes care of registering new votes, if the vote button
 * has been pressed.
 */
function decisions_voting_form($form, &$node, $teaser = FALSE, $page = FALSE) {
  $mode = _decisions_get_mode($node);
  if (function_exists("{$mode}_decisions_voting_form")) {
    return call_user_func("{$mode}_decisions_voting_form", $node, $teaser, $page);
  }
  else {
    _decisions_panic_on_mode($mode, __FUNCTION__);
  }
}

function decisions_voting_form_submit($form, &$form_state) {
  $node = node_load($form_state['values']['nid']);
  decisions_vote($node, $form_state['values']);
  drupal_set_message(t('Your vote was registered.'));
  // Transferring makes the results tab display correctly
  drupal_goto('node/' . $node->nid);
}

/**
 * Validate vote form submission
 *
 * This will call a hook named decisions_vote_validate_$mode and
 * return its value. hooks should check $POST to see if the vote data
 * submitted is valid and use form_set_error() if the form has invalid
 * data.
 *
 * @returns boolean true if form has valid data or if no hook is
 * defined in mode
 */
function decisions_voting_form_validate($form, &$form_state) {
  $node = node_load($form_state['values']['nid']);
  $mode = _decisions_get_mode($node);
  if (function_exists("{$mode}_decisions_vote_validate") ) {
    return call_user_func("{$mode}_decisions_vote_validate", $node, $form_state['values']);
  }
  return TRUE;
}

/**
 * Record a vote on the node.
 *
 * This calls the appropriate vote recording function, depending on
 * the mode. It will call the decisions_vote_$mode hook.
 */
function decisions_vote($node, $form_values) {
  $mode = _decisions_get_mode($node);
  $ok = FALSE; // error by default
  if (_decisions_eligible($node)) {
    if (function_exists("{$mode}_decisions_vote")) {
      call_user_func("{$mode}_decisions_vote", $node, $form_values);
    }
    else {
      _decisions_panic_on_mode($mode, __FUNCTION__);
    }
  }
  else {
    drupal_set_message(t('You are not eligible to vote on this decision.'));
  }
}

/**
 * Helper function to list algorithms for a given mode
 */
function decisions_algorithms($mode) {
  $algs = array();
  if (function_exists("{$mode}_decisions_algorithms")) {
    $algs = call_user_func("{$mode}_decisions_algorithms");
    $error = false;
    if (!is_array($algs)) {
      $error = t('Element returned by the call to function @function is not an array, returning dummy value.', 
                    array('@function' => "decisions_{$mode}_algorithms"));
    } else if (count($algs) == 0) {
      $error = t('Array returned by the call to function @function is empty, returning dummy value.', 
                    array('@function' => "decisions_{$mode}_algorithms"));      
    }
    if ($error) {
      watchdog('decisions', $error, WATCHDOG_WARNING);
      drupal_set_message($error, 'warning');
    }
  }
  else {
    _decisions_panic_on_mode($mode, __FUNCTION__);
  }
  return $algs;
}


/*************/
/* Callbacks */
/*************/

/**
 * Callback for canceling a vote.
 */
function decisions_cancel($nid) {
  if ($node = node_load($nid)) {
    if ($node->voted && $node->active) {
      $criteria = votingapi_current_user_identifier();
      $criteria['content_type'] = 'decisions';
      $criteria['content_id'] = $node->nid;
      votingapi_delete_votes(votingapi_select_votes($criteria));
      drupal_set_message(t('Your vote was canceled.'));
    }
    else {
      drupal_set_message(t("You are not allowed to cancel an invalid choice."), 'error');
    }
    drupal_goto('node/'. $nid);
  }       
  else {
    drupal_not_found();
  }
}

/**
 * Callback to display the votes tab.
 */
function decisions_votes_tab() {
  if ($node = menu_get_object()) {
    if (!$node->showvotes) {
      // Decision is set to not allow viewing of votes
      drupal_not_found();
      return;
    }
    drupal_set_title(check_plain($node->title));
    $output = t('This table lists all the recorded votes for this Decision. If anonymous users are allowed to vote, they will be identified by the IP address of the computer they used when they voted.');

    $header[] = array('data' => t('Visitor'), 'field' => 'u.name');
    $header[] = array('data' => t('Vote'), '');

    $result = pager_query('SELECT v.value, v.uid, v.vote_source, v.tag, u.name FROM {votingapi_vote} v LEFT JOIN {users} u ON v.uid = u.uid WHERE v.content_id = %d' . tablesort_sql($header), 20, 0, NULL, $node->nid);
    $votes = array();
    $names = array();
    while ($vote = db_fetch_object($result)) {
      $key = $vote->uid? $vote->uid : $vote->vote_source;
      $votes[$key][] = $vote;
      $names[$key] = $vote->name ? theme('username', $vote) : check_plain($vote->vote_source);
    }

    $mode = _decisions_get_mode($node);
    $function_format_votes = "{$mode}_decisions_format_votes";
    if (!function_exists($function_format_votes)) {
      _decisions_panic_on_mode($mode, __FUNCTION__);
      drupal_not_found();
    }
    
    $rows = array();
    foreach ($names as $key => $name) {
      $rows[$key]['name'] = $name;
      $rows[$key]['vote'] = call_user_func($function_format_votes, $node, $votes[$key]);
    }

    $output .= theme('table', $header, $rows);
    $output .= theme('pager', NULL, 20, 0);
    print theme('page', $output);
  }
  else {
    drupal_not_found();
  }
}


/**********************/
/* Internal functions */
/**********************/

/**
 * Callback function to see if a node is acceptable for poll menu items.
 */
function _decisions_votes_access($node, $perm) {
  return user_access($perm) && $node->showvotes;
}

function _decisions_electoral_list_access($node, $perm) {
  return user_access($perm) && $node->uselist;
}

/**
 * Function that tells if the given decision is open to votes.
 */
function _decisions_is_open($node) {
  $time = time();
  return ($node->active &&                    // node must be active
          // current time must be past start date and before end date
          ($time >= $node->startdate) &&
          ($node->runtime == DECISIONS_RUNTIME_INFINITY ||
           $time < ($node->startdate + $node->runtime)));
}

/**
 * Function that tells if the given user can vote on this decision.
 */
function _decisions_can_vote($node, $user = NULL) {
  return (_decisions_is_open($node) &&         // node must be open
          !$node->voted &&                    // user should not have already voted
          _decisions_eligible($node, $user));  // user must be eligible to vote
}

/**
 * Function that tells if the given decision meets the quorum.
 */
function _decisions_meets_quorum($node) {
  // compute number of people that have cast their vote
  $num_voters = 0;
  if ($result = db_fetch_object(db_query("SELECT COUNT(DISTINCT uid) AS voters FROM {votingapi_vote} WHERE content_id=%d GROUP BY uid", $node->nid))) {
    $num_voters = $result->voters;
  }
  $quorum = _decisions_get_quorum($node);
  return ($num_voters >= $quorum);
}


/**
 * Internal function factored out that just rings lots of bells when
 * we detect an unknown mode.
 */
function _decisions_panic_on_mode($mode, $function = '') {
  watchdog('decisions', 'Unknown decision mode : @mode in "@function".', array('@mode' => $mode, '@function' => $function, WATCHDOG_ERROR));
  drupal_set_message(t('Unknown decision mode : @mode in "@function".', array('@mode' => $mode, '@function' => $function), 'error'));
}

/**
 * Get all votes from the given node.
 */
function _decisions_votes($node) {
  $votes = array();
  // ORDER BY value ASC lets us ensure no gaps
  $result = db_query("SELECT * FROM {votingapi_vote} v WHERE content_type='%s' AND content_id='decisions' ORDER BY value ASC", $node->nid);
  while ($vobj = db_fetch_object($result)) {
    $votes[] = $vobj;
  }
  return $votes;
}

/**
 * Count the elligible voters for a given decision.
 */
function _decisions_count_eligible($node) {
  if ($node->uselist) {
    $result = db_fetch_object(db_query("SELECT COUNT(*) AS num FROM {decisions_electoral_list} WHERE nid=%d", $node->nid));
    return $result->num;    
  } else {
    // check first if authenticated users have the right to vote, because authenticated users are not added to the users_roles permission, probably for performance reasons
    $result = db_fetch_object(db_query("SELECT COUNT(*) AS hit FROM {permission} JOIN role ON role.rid = permission.rid WHERE FIND_IN_SET(' vote on decisions', perm) AND role.name = 'authenticated user'"));
    if ($result->hit) {
      // special case: any authenticated user can vote
      // consider all current to be elligible
      $result = db_fetch_object(db_query("SELECT COUNT(*) AS num FROM {users} u WHERE u.uid != 0"));
      return $result->num;
    }
    else {
      // all users are elligible, add relevant users only
      $result = db_fetch_object(db_query("SELECT COUNT(DISTINCT ur.uid) AS num FROM {users_roles} ur JOIN {permission} p ON ur.rid = p.rid WHERE FIND_IN_SET(' vote on decisions', p.perm) AND ur.uid != 0"));
      return $result->num;
    }
  }
}

/**
 * Returns the quorum (minimum voters) of a node.
 */
function _decisions_get_quorum($node) {
  $num_eligible_voters = _decisions_count_eligible($node);
  $quorum = $node->quorum_abs + ceil(($node->quorum_percent / 100.0) * $num_eligible_voters);
  return min($quorum, $num_eligible_voters);
}

/**
 * Get all votes by uid in a an array, in a uid => votes fashion.
 */
function _decisions_user_votes($node) {
  $votes = _decisions_votes($node);
  
  // aggregate votes by user (uid if logged in, IP if anonymous)
  // in ascending order of value
  $userVotes = array();

  foreach ($votes as $vote) {
    $key = ($vote->uid == 0 ? $vote->vote_source: $vote->uid);
    $user_votes[$key][] = $vote;
  }
  
  return $user_votes;
}

/**
 * Check if user is eligible to this decision.
 */
function _decisions_eligible($node, $uid = NULL) {
  global $user;
  if (is_null($uid)) {
    $uid = $user->uid;
  }

  if ($node->uselist) {
    $can_vote = db_fetch_object(db_query("SELECT COUNT(*) AS eligible FROM {decisions_electoral_list} WHERE nid=%d AND uid=%d", $node->nid, $uid));
    $eligible = $can_vote->eligible;
  }
  else {
    $eligible = user_access('vote on decisions');
  }
  return $eligible;
}

/**
 * Constructs the time select boxes.
 * 
 * @ingroup event_support
 * @param $timestamp The time GMT timestamp of the event to use as the default
 *   value.
 * @return An array of form elements for month, day, year, hour, and minute
 */
function _decisions_form_date($timestamp) {
  // populate drop down values...
  // ...months
  $months = array(1 => t('January'), t('February'), t('March'), t('April'), t('May'), t('June'), t('July'), t('August'), t('September'), t('October'), t('November'), t('December'));
  // ...hours
  if (variable_get('event_ampm', '0')) {
    $hour_format = t('g');
    $hours = drupal_map_assoc(range(1, 12));
    $am_pms = array('am' => t('am'), 'pm' => t('pm'));
  }
  else {
    $hour_format = t('H');
    $hours = drupal_map_assoc(range(0, 23));
  }
  // ...minutes (with leading 0s)
  for ($i = 0; $i <= 59; $i++) $minutes[$i] = $i < 10 ? "0$i" : $i;

  // XXX: what is this for?
  $offset = 0;

  // This is a GMT timestamp, so the _event_date() wrapper to display local times.
  $form['day'] = array(
    '#prefix' => '<div class="container-inline"><div class="day">',
    '#type' => 'textfield',
    '#default_value' => _decisions_date('d', $timestamp, $offset),
    '#maxlength' => 2,
    '#size' => 2,
    '#required' => TRUE);
  $form['month'] = array(
    '#type' => 'select',
    '#default_value' => _decisions_date('m', $timestamp, $offset),
    '#options' => $months,
    '#required' => TRUE);
  $form['year'] = array(
    '#type' => 'textfield',
    '#default_value' => _decisions_date('Y', $timestamp, $offset),
    '#maxlength' => 4,
    '#size' => 4,
    '#required' => TRUE);
  $form['hour'] = array(
    '#prefix' => '</div>&#8212;<div class="time">',
    '#type' => 'select',
    '#default_value' => _decisions_date($hour_format, $timestamp, $offset),
    '#options' => $hours,
    '#required' => TRUE);
  $form['minute'] = array(
    '#prefix' => ':',
    '#type' => 'select',
    '#default_value' => _decisions_date('i', $timestamp, $offset),
    '#options' => $minutes,
    '#required' => TRUE);
  if (isset($am_pms)) {
    $form['ampm'] = array(
      '#type' => 'radios',
      '#default_value' => _decisions_date('a', $timestamp, $offset),
      '#options' => $am_pms,
      '#required' => TRUE);
  }
  $form['close'] = array(
    '#type' => 'markup',
    '#value' => '</div></div>');

  return $form;
}

/**
 * Takes a time element and prepares to send it to form_date()
 * 
 * @param $time
 *   The time to be turned into an array. This can be:
 *   - a timestamp when from the database
 *   - an array (day, month, year) when previewing
 *   - null for new nodes
 * @returnn
 *   an array for form_date (day, month, year)
 */
function _decisions_form_prepare_datetime($time = '', $offset = 0){
  // if this is empty, get the current time
  if($time == ''){
    $time = time();
    $time = strtotime("+$offset days", $time);
  }
  // If we are previewing, $time will be an array so just pass it through
  $time_array = array();
  if(is_array($time)){
  	$time_array = $time;
  } 
  // otherwise build the array from the timestamp
  elseif(is_numeric($time)){
    $time_array = array(
      'day' => _decisions_date('j', $time),
      'month' => _decisions_date('n', $time),
      'year' => _decisions_date('Y', $time),
      'hour' => _decisions_date('H', $time),
      'min' => _decisions_date('i', $time),
      'sec' => _decisions_date('s', $time),
    );
  }
  // return the array
  return $time_array;
}

/**
 * Content of the block, as returned by decisions_block('view')
 */
function _decisions_block_mostrecent() {
  $output = '';
  $result = db_query('SELECT nid FROM {decisions} WHERE active=1 ORDER BY nid DESC LIMIT 1');
  // Check that there is an active decision
  if ($decision = db_fetch_object($result)) {
    $n = decisions_view(node_load($decision->nid), false, false, true);
    /* XXX: we have to do this because somehow the #printed settings lives across multiple node_load */
    unset($n->content['#printed']);
    $output = drupal_render($n->content);
  }
  else {
    $output = t('No active decisions.');
  }
  return $output;
}

/**
 * Returns true if the user can view the results of current node.
 */
function _decisions_can_view_results($node) {
  $view_results = variable_get('decisions_view_results', DECISIONS_DEFAULT_VIEW_RESULTS);
  return (_decisions_meets_quorum($node) && // node meets the quorum
          (!_decisions_is_open($node)       // node is closed
          || ($node->voted && $view_results == 'aftervote') // user voted
          || ($view_results == 'always'))); // all can view
}

?>
