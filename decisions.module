<?php
// $Id$
/**
 * @file
 * Modular voting mechanisms, delegatable votes, taxonomy/category influenced controls and weighted voting
 * See http://decisions.gnuvernment.org for more information on the project.
 *
 * Heavily inspired by other Drupal modules, mostly from poll.module, but we adapted it to "drupal forms api".
 * Thanks to everyone for all the that was already written. (...and debugged!)
 */


define('DECISIONS_DEFAULT_ELECTORAL_LIST', 0);
// always, aftervote, or afterclose
define('DECISIONS_DEFAULT_VIEW_RESULTS', "aftervote");

/**
 * Implementation of hook_access().
 */
function decisions_access($op, $node) {
  global $user;

  if ($op == 'create') {
    return user_access('create decisions');
  }
  if ($op == 'delete') {
    return user_access('delete decisions');
  }
  if ($op == 'update') {
    /* you can update it if you can create it, provided it is your own... */
    if (user_access('create decisions') && ($user->uid == $node->uid)) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_block().
 */
function decisions_block($op = 'list', $delta = 0, $edit = array()) {
  switch($op) {
    case 'list' :
      $blocks[0]['info'] = t('A decisions block');
      return $blocks;
    case 'view' :
      $blocks["content"] = decisions_block_contents();
      $blocks["subject"] = "decisions";
      return $blocks;
  }
}

/**
 * Content of the block, as returned by decisions_block('view')
 */
function decisions_block_contents() {
  $block = '';
  if ( user_access('view decisions') ) {
    /* get list of decisions and show them */
    if ( user_access('vote on decisions') ) {
      /* add a link to vote on the decision */
    }
  }
  return $block;
}

/**
 * Implementation of hook_cron().
 *
 * Closes decisions that have exceeded their allowed runtime.
 */
function decisions_cron() {
  $result = db_query('SELECT d.nid FROM {decisions} d INNER JOIN {node} n ON d.nid = n.nid WHERE (n.created + d.runtime) < '. time() .' AND d.active = 1 AND d.runtime != 0');
  while ($decision = db_fetch_object($result)) {
    db_query("UPDATE {decisions} SET active = 0 WHERE nid=%d", $decision->nid);
  }
}


/**
 * Implementation of hook_delete().
 *
 */
function decisions_delete($node) {
  db_query("DELETE FROM {decisions} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {decisions_choices} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {decisions_electoral_list} WHERE nid = %d", $node->nid);

	// Note: this should be converted to a votingapi method eventually
	db_query("DELETE FROM {votingapi_vote} WHERE content_id = %d", $node->nid);
}

/**
 * Implementation of votingapi_hook_calculate()
 */
function decisions_votingapi_calculate(&$cache, $votes, $content_type, $content_id) {
  $node = node_load($content_id);
	$mode = _decisions_get_mode($node);
  if (function_exists("decisions_votingapi_calculate_$mode")) {
  	//return call_user_func("decisions_votingapi_calculate_$mode", $node, $cache, $votes, $content_type, $content_id);
  }
}



/**
 * Implementation of hook_form().
 *
 * This hook displays the form necessary to edit the *node* (ie. not the votes).
 */
function decisions_form($node) {
	$node->in_preview = isset($_POST['edit']);

	$mode = _decisions_get_mode($node);

	$enabled = array(0 => t('Disabled'), 1 => t('Enabled'));

  /* standard node elements */
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => ucfirst($mode) . ' ' . t('Question'),
    '#required' => TRUE,
    '#default_value' => $node->title,
  );

  $form['body'] = array(
    '#type' => 'textarea',
    '#title' => t('Description'),
    '#required' => FALSE,
    '#default_value' => $node->body,
  );

	if ($node->in_preview) {
		// Figure out the number of non-blank choices
		$node->choice = array();
		$node->choices = 0;
  	foreach ($_POST['edit']['ChoiceGroup'] as $key => $choice) {
  		$order = str_replace('Choice_', '', $key);
			if ($order != $key && $choice != '') {
				$node->choices++;
				$node->choice[$order] = $choice;
			}
			else {
				
			}
		}

		// If all of them are blank, default to 5 again
		if ($node->choices == 0) {
			$node->choices = 5;
		}
	}

  if (!isset($node->choices)) {
		// in the process of creating a new decision

		if ($node->in_preview) {
			// previewing a decision that hasn't been created yet

			if ($_POST['edit']['ChoiceGroup']['morechoices']) {
				// morechoices checked

				// double number of previously shown choices (including blanks)
				$node->choices = 2 * $_POST['edit']['ChoiceGroup']['choices'];
			}
			else {
				// morechoices not checked

				// Only show non-blank previous choices

				// $node->choices should already be set to the correct number
				// so don't do anything.
			}
		}
		else {
			// this is a new decision, so default to 5 choices	
    	$node->choices = 5;
		}
	}
	else {
		// Editing an old decision

		if ($node->in_preview) {
			// previewing a previously edited node

			if ($_POST['edit']['ChoiceGroup']['morechoices']) {
				// Double number of previously shown choices, including blanks
				$node->choices = 2 * $_POST['edit']['ChoiceGroup']['choices'];
			}
			else {
				// morechoices not checked

				// Only show non-blank previous choices

				// $node->choices should already be set to the correct number
				// so don't do anything.
			}
		}
  }

	// Choices list
  $form['ChoiceGroup'] = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#title' => t('Decision Choices'),
    '#collapsible' => TRUE,
  );

  for ($cnum = 1; $cnum <= $node->choices; $cnum++) {
    $form['ChoiceGroup']['Choice_' . $cnum] = array(
      '#type' => 'textfield',
      '#title' => t('Choice %n', array('%n' => $cnum)),
      '#required' => FALSE,
      '#default_value' => $node->choice[$cnum],
      '#size' => 50,
      '#maxlength' => 127,
    );
  }

  $form['ChoiceGroup']['choices'] = array(
    '#type' => 'hidden',
    '#value' => $node->choices,
  );

  $form['ChoiceGroup']['morechoices'] = array(
    '#type' => 'checkbox',
    '#title' => t('Need more choices'),
    '#value' => 0,
    '#description' => t("If the amount of boxes above isn't enough, check this box and click the Preview button below to add some more."),
  );

	$form['settings'] = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#title' => t('Decision Settings'),
    '#collapsible' => TRUE,
  );

	$maxChoiceList = array();
	for ($i = 0; $i <= $node->choices; $i++) {
		$maxChoiceList[$i] = ($i == 0? 'No limit' : $i);
	}


  $form['settings']['maxchoices'] = array(
		'#type' => 'select',
		'#title' => t('Maximum Choices'),
		'#default_value' => ($node->maxchoices? $node->maxchoices : 0),
		'#options' => $maxChoiceList,
		'#description' => t('Limits the total number of choices voters may select.')
	);

	$voting_algorithms = array();
	if ($mode == 'ranking') {
		$algs = array('instant runoff', 'borda count');
	}
	else {
		// mode == poll
		$algs = array('plurality');
	}

	foreach ($algs as $alg) {
		$voting_algorithms[$alg] = ucwords($alg);
	}

	$defaultalg = ($_POST['edit']['settings']['algorithm']?
		$_POST['edit']['settings']['algorithm'] : 
			$node->algorithm);
			

	$form['settings']['algorithm'] = array(
		'#type' => 'select',
		'#title' => t('Algorithm'),
		'#options' => $voting_algorithms,
		'#default_value' => $defaultalg,
		'#description' => 'Voting algorithm to use to calculate the winner.',
	);

/*
	$form['settings']['maxchoices'] = array(
		'#type' => 'textfield',
		'#required' => TRUE,
		'#title' => t('Maximum Choices'),
		'#size' => 5,
		'#maxlength' => 10,
		'#description' => t('The number of choices voters may select. Set to 0 for no limit.'),
   	'#default_value' => (isset($node->settings['maxchoices'])?
			$node->settings['maxchoices'] : 0),
	);
	*/

	$active = array(1 => t('Active'), 0 => t('Closed'));
	$form['settings']['active'] = array(
		'#type' => 'radios',
		'#title' => t('Decision Status'),
		'#options' => $active,
		'#default_value' => (isset($node->active)? $node->active : 1),
		'#description' => t('When a decision is closed users may no longer vote on it.'),
	);

  $_duration = array(0 => t('Unlimited')) + drupal_map_assoc(array(86400, 172800, 345600, 604800, 1209600, 2419200, 4838400, 9676800, 31536000), 'format_interval');

  $form['settings']['runtime'] = array(
		'#type' => 'select',
		'#title' => t('Decision duration'),
		'#default_value' => ($node->runtime? $node->runtime : 0),
		'#options' => $_duration,
		'#description' => t('After this period, the decision will be closed automatically.')
	);


	// only show for new decisions (not when editing)
	if (!(isset($node) && $node->nid)) {

  	// to pick a reasonable default, configurable
		/*
  	$modes = _decisions_mode_list();

	  $form['settings']['mode'] = array(
			'#type' => 'select',
			'#title' => t('Decision mode'),
			'#required' => TRUE,
			'#choices' => _decisions_mode_list(),
			'#default_value' => variable_get('decisions_default_mode', $modes[0]),
  	);
		// */

		$form['settings']['uselist'] = array(
			'#type' => 'checkbox',
			'#title' => t('Set the eligible voters upon creation'),
			'#description' => t('If enabled, a list of eligible voters will be created and only that group will be able to vote in the decision.'),
			'#default_value' => variable_get('decisions_default_electoral_list', DECISIONS_DEFAULT_ELECTORAL_LIST),
		);
	}
  
	$form['format'] = filter_form($node->form);
	return $form;
}


/**
 * Implementation of hook_help().
 */
function decisions_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Allow people to reproduce and surpass the kinds of decision-making instances that exist in face-to-face meetings.');
    case 'node/add#decisions-poll':
      return t('Create a decision using a poll interface.');
    case 'node/add#decisions-ranking':
      return t('Create a decision using a ranking interface.');
  }
}

/**
 * Implementation of hook_load().
 *
 * Load the votes and decision-specific data into the node object.
 */
function decisions_load($node) {
	global $user;
  $decision = db_fetch_object(db_query("SELECT * FROM {decisions} WHERE nid = %d", $node->nid));
  $result = db_query("SELECT chorder, chtext FROM {decisions_choices} WHERE nid = %d ORDER BY chorder", $node->nid);
  while ($choice = db_fetch_array($result)) {
  	$decision->choice[$choice['chorder']] = $choice['chtext'];
  }
  $decision->choices = count($decision->choice);

	$decision->voted = false;
	// See if user has voted
	if ($user->uid) {
		$decision->voted = (count(votingapi_get_user_votes('decisions', $node->nid)) > 0);
	}
	else {
		$result = db_fetch_object(db_query('SELECT value FROM {votingapi_vote} '
			. 'WHERE content_id=%d AND ' . 'hostname="%s"',
			$node->nid, $_SERVER['REMOTE_ADDR']));
		if ($result->value) {
			$decision->voted = true;
		}
	}

  return $decision;
}

/**
 * Implementation of hook_menu().
 *
 * Just a path for creating new decisions for now, but we could
 * eventually have a 'my decisions' and 'view decisions' kind of
 * page. (TODO)
 */
function decisions_menu($may_cache) {
  global $user;

  // load the necessary submodules in here instead of _init() to
  // profit from caching, as recommended by
  // http://drupaldocs.org/api/head/function/hook_init
  _decisions_load_modes();

  $items = array();

  if ($may_cache) {
    $items[] = array('path' => 'node/add/decisions-ranking',
			'title' => t('decisions-ranking'),
      'access' => user_access('create decisions'),
		);

    $items[] = array('path' => 'node/add/decisions-poll',
			'title' => t('decisions-poll'),
      'access' => user_access('create decisions'),
		);

		$items[] = array('path' => 'decisions/cancel',
			'title' => t('cancel'),
			'callback' => 'decisions_cancel',
			'access' => user_access('cancel own vote'),
			'type' => MENU_CALLBACK);
			// */
    /*
    $items[] = array('path' => 'decisions', 'title' => t('decisions'),
      'callback' => 'decision_page',
      'access' => user_access('view decisions'),
      'type' => MENU_SUGGESTED_ITEM);
    $items[] = array('path' => 'decisions/'. $user->uid, 'title' => t('my decisions'),
      'access' => user_access('create decisions'),
      'type' => MENU_DYNAMIC_ITEM);
    */
  }
	else {
		// need to be able to extract the nid
		if (arg(0) == 'node' && is_numeric(arg(1))) {
			$nid = arg(1);
			$node = node_load($nid);
			if ($node->active && !$node->voted && _decisions_can_view_results($node)) {
				$items[] = array('path' => 'node/' . $nid . '/results',
					'title' => t('results'),
					'callback' => 'decisions_results',
					'access' => user_access('view decisions'),
					'weight' => 3,
					'type' => MENU_LOCAL_TASK);
			}
		}
	}

  return $items;
}

function _decisions_can_view_results($node) {
	$view_results = variable_get('decisions_view_results'
		, DECISIONS_DEFAULT_VIEW_RESULTS);
	return (!$node->active  // node is closed
				|| ($node->voted && $view_results == 'aftervote') // user voted
				|| ($view_results == 'always')); // all can view
}

/**
 * Implementation of hook_node_info().
 */
function decisions_node_info() {
  return array(
		'decisions-ranking' => array('name' => t('decisions-ranking'), 'base' => 'decisions'),
		'decisions-poll' =>    array('name' => t('decisions-poll'),    'base' => 'decisions'),
	);
}

/**
 * Implementation of hook_perm().
 */
function decisions_perm() {
  return array('create decisions', 'delete decisions', 'view decisions', 'vote on decisions', 'cancel own vote', 'administer decisions');
}

/**
 * Implementation of hook_settings().
 *
 */
function decisions_settings() {
	if (!user_access('administer decisions')) {
		return message_access();
	}

	$enabled = array(0 => t('Disabled'), 1 => t('Enabled'));

	$form['main']['decisions_default_electoral_list'] = array(
		'#type' => 'radios',
		'#title' => t('Use electoral list by default'),
		'#description' => t('Use an electoral list by default for new decisions.'),
		'#default_value' => variable_get('decisions_default_electoral_list', DECISIONS_DEFAULT_ELECTORAL_LIST),
		'#options' => $enabled,
	);

	$view_results = array(
		'always' => t('Always'),
		'aftervote' => t('After user has voted'),
		'afterclose' => t('After voting has closed'),
	);

	$form['main']['decisions_view_results'] = array(
		'#type' => 'radios',
		'#title' => t('When should results be displayed'),
		'#description' => t('Determines when users may view the results of the decision.'),
		'#default_value' => variable_get('decisions_view_results', DECISIONS_DEFAULT_VIEW_RESULTS),
		'#options' => $view_results,
	);

	return $form;
}

function decisions_cancel_form($nid) {
  $form['#action'] = url("decisions/cancel/$nid");
  $form['submit'] = array('#type' => 'submit', '#value' => t('Cancel your vote'));
  return $form;	
}

/**
 * Implementation of hook_update().
 *
 * This is called upon node edition.
 */
function decisions_update($node) {
  db_query("UPDATE {decisions} SET active=%d, runtime=%d, maxchoices=%d, algorithm='%s' WHERE nid = %d", $node->settings['active'], $node->settings['runtime'], $node->settings['maxchoices'], $node->settings['algorithm'], $node->nid);
  # XXX: should update decisions here, when it has some parameters
  # XXX: ... but before doing so, the code below must be factored out in a seperate function for usage in decisions_insert()
  db_query('DELETE FROM {decisions_choices} WHERE nid = %d', $node->nid);

  foreach ($node->ChoiceGroup as $key => $choice) {
  	$order = str_replace('Choice_', '', $key);
		if ($order != $key && $choice != '') {
			db_query("INSERT INTO {decisions_choices} (nid, chtext, chorder) VALUES (%d, '%s', %d)", $node->nid, $choice, intval($order));
	  }
	# ignore entries other than choices
  }
}

function _decisions_get_mode($node) {
	if ($node->type) {
		$types = explode('-', $node->type, 2);
		return $types[1];
	}
	else {
		drupal_set_error('No type specified for node: ' . $node->nid);
		return '';
	}
}

/**
 * Implementation of hook_insert()
 *
 * This is called upon node creation
 */
function decisions_insert($node) {
  # just create an empty entry for now
	$mode = _decisions_get_mode($node);
	if ($mode == 'poll') {
		$alg = 'poll';
	} else if ($mode == 'ranking') {
		$alg = 'runoff';
	}
  db_query("INSERT INTO {decisions} (nid, mode, uselist, active, runtime, maxchoices, algorithm) VALUES (%d, '%s', %d, %d, %d, %d, '%s')", $node->nid, $mode, $node->settings['uselist'], $node->settings['active'], $node->settings['runtime'], $node->settings['maxchoices'], $alg);

  # create the electoral list if desired

	if ($node->uselist) {

  	# check first if authenticated users have the right to vote, because authenticated users are not added to the users_roles permission, probably for performance reasons
  	$result = db_fetch_object(db_query("SELECT COUNT(*) AS hit FROM {permission} JOIN role ON role.rid = permission.rid WHERE FIND_IN_SET(' vote on decisions', perm) AND role.name = 'authenticated user'"));
  	if ($result->hit) {
    	# special case: any authenticated user can vote
    	# add all current users to electoral list
    	db_query("INSERT INTO {decisions_electoral_list} (nid, uid) SELECT '%d', u.uid FROM users u WHERE u.uid != 0", $node->nid);
  	}
  	else {
			# all users must not be allowed to vote, add relevant users only
    	db_query("INSERT INTO {decisions_electoral_list} (nid, uid) SELECT '%d', u.uid FROM users_roles u, permission p WHERE FIND_IN_SET(' view decisions', p.perm) AND u.rid = p.rid AND u.uid != 0", $node->nid);
  	}
	}

  # insert the choices, same sequence than update
  decisions_update($node);
}

/**
 * Implementation of hook_validate().
 *
 * XXX: No validation yet.
 */
function decisions_validate($node) {
  // Use form_set_error for any errors
	/*
	if (!$node->mode) {
		form_set_error(t('No mode selected.'));
	}
	*/
}

/**
 * Implementation of hook_view().
 */
function decisions_view(&$node, $teaser = FALSE, $page = FALSE, $block = FALSE) {
  $node = node_prepare($node, $teaser);
	$mode = _decisions_get_mode($node);

	// Record the vote if they voted
  $valid = FALSE;
  if ($_POST['op'] == t('Vote')) {
    // decision_vote will return FALSE on error
    $valid = decisions_vote_validate($node);
    if ($valid) {
      drupal_set_message(t("Your vote was registered."));
      decisions_vote($node);
			// Transferring makes the results tab display correctly
			drupal_goto('node/' . $node->nid);
    }
  }

	// Previewing a node, so don't show results
	if ($node->in_preview) {
		// Copy the form values to the choices array
		$node->choice = array();
		$node->choices = 0;
  	foreach ($node->ChoiceGroup as $key => $choice) {
  		$order = str_replace('Choice_', '', $key);
			if ($order != $key && $choice != '') {
				$node->choices++;
				$node->choice[$order] = $choice;
			}
		}

		// Show the voting form but don't let them vote
    $output .= decisions_view_voting($node, $teaser, $page, $block);
	}
  else if (!$node->voted && arg(2) != 'results' && $node->active) {
		// User hasn't voted and we're not on the results tab
		if (!$valid && decisions_eligible($node)) {
      $output .= decisions_view_voting($node, $teaser, $page, $block);
    }
	}
	else if (_decisions_can_view_results($node)) {
		// show results only if the user has voted or decision is closed
    $output .= decisions_view_results($node, $teaser, $page, $block);
  	$output .= decisions_view_electoral_list($node, $teaser);
		if (isset($node->voted) && $node->voted && user_access('cancel own vote') && $node->active) {
			$output .= drupal_get_form('decisions_cancel', decisions_cancel_form($node->nid));
		}
  }
	else {
		$output .= 'this is bad';
	}


  $node->body .= $output;
  $node->teaser .= $output;

}

function decisions_view_electoral_list($node, $teaser = FALSE) {
  $output = '';
  if (!$teaser) {
		if ($node->uselist) {
    	$result = db_query("SELECT COUNT(*) AS voters FROM {decisions_electoral_list} WHERE nid=%d", $node->nid);
    	$electoral_list = db_fetch_object($result);
		}
    $result = db_query("SELECT COUNT(DISTINCT uid) AS voters FROM {votingapi_vote} WHERE content_id=%d GROUP BY uid", $node->nid);
    $votes = db_num_rows($result);

    $output = '<div class="decisions-electoral-list">';

		$output .= t('Total votes: %d', array('%d' => $votes));
		if ($node->uselist) {
    	$output .= t('(out of %v eligible voter' . 
				($electoral_list->voters == 1? '' : 's') . ')',
					array('%v' => $electoral_list->voters));
		}
    $output .= '</div>';
  }
  return $output;
}

/**
 * Theme stub for redering the voting form, to allow the chance for
 * themes to make this nicer/different
 */
function theme_decisions_view_voting($form) {
  $output .= '<div class="decisions">';
  $output .= '  <div class="choice-form">';
  $output .= '    <div class="choices">';
  $output .= form_render($form['choice']);
  $output .= '    </div>';
  $output .= form_render($form['nid']);
  $output .= form_render($form['vote']);
  $output .= '  </div>';
  $output .= form_render($form);
  $output .= '</div>';
  return $output;
}

function theme_decisions_bar($title, $percentage, $votes, $block) {
  if ($block) {
    $output  = '<div class="text">'. $title .'</div>';
    $output .= '<div class="bar"><div style="width: '. $percentage .'%;" class="foreground"></div></div>';
    $output .= '<div class="percent">'. $percentage .'%</div>';
  }
  else {
    $output  = '<div class="text">'. $title .'</div>';
    $output .= '<div class="bar"><div style="width: '. $percentage .'%;" class="foreground"></div></div>';
    $output .= '<div class="percent">'. $percentage .'% ('. $votes .')</div>';
  }
  return $output;
}

/**
 * View the voting form.
 *
 * This calls a function decisions_vote_$mode, where $mode is defined
 * in the node. If the function does not exist, a watchdog error is
 * raised and the error is reported using drupal_set_message().
 *
 * This also takes care of registering new votes, if the vote button
 * has been pressed.
 */
function decisions_view_voting(&$node, $teaser, $page, $block) {

	$mode = _decisions_get_mode($node);
  if ( function_exists("decisions_view_voting_$mode") ) {
    return call_user_func("decisions_view_voting_$mode", $node, $teaser, $page, $block);
  }
  else {
    _decisions_panic_on_mode($mode);
  }
}

/**
 * Callback for 'results' tab for decisions you can vote on
 */

function decisions_results() {
	if ($node = node_load(arg(1))) {
		drupal_set_title(check_plain($node->title));
		return node_show($node, 0);
	}
	else {
		drupal_not_found();
	}
}
/**
 * show results of the vote
 *
 * this calls the appropriate vote results function, depending on the
 * mode. It will call decisions_view_results_$mode, similarly to
 * decisions_view_voting().
 */
function decisions_view_results(&$node, $teaser, $page, $block) {
	$mode = _decisions_get_mode($node);
  if ( function_exists("decisions_view_results_$mode") ) {
    return call_user_func("decisions_view_results_$mode", $node, $teaser, $page, $block);
  }
  else {
    _decisions_panic_on_mode($mode);
  }
}

/**
 * record a vote on the node
 *
 * this calls the appropriate vote recording function, depending on
 * the mode. It will call decisions_vote_$mode, similarly to
 * decisions_view_voting().
 */
function decisions_vote($node) {
	$mode = _decisions_get_mode($node);

  $ok = FALSE; // error by default
  if ( decisions_eligible($node) ) {
    if ( function_exists("decisions_vote_$mode") ) {
      call_user_func("decisions_vote_$mode", $node);
    }
    else {
      _decisions_panic_on_mode($mode);
    }
  }
  else {
    drupal_set_message(t('You are not eligible to vote on this decision.'));
  }
}

/**
 * Callback for canceling a vote
 */
function decisions_cancel($nid) {
	global $user;
	$nid = arg(2);
  if ($node = node_load(array('nid' => $nid))) {
    if ($node->voted && $node->active) {
      if ($user->uid) {
				votingapi_unset_vote('decisions', $node->nid, $user->uid);
      }
      else {
        db_query("DELETE FROM {votingapi_votes} WHERE content_id=%d and hostname = '%s'", $node->nid, $_SERVER['REMOTE_ADDR']);
      }
      drupal_set_message(t('Your vote was canceled.'));
    }
    else {
      drupal_set_message(t("You are not allowed to cancel an invalid choice."), 'error');
    }
		drupal_goto('node/'. $nid);
 	}	
  else {
		drupal_not_found();
	}
}

/**
 * validate vote form submission
 *
 * this will call a hook named decisions_vote_validate_$mode and
 * return its value. hooks should check $POST to see if the vote data
 * submitted is valid and use form_set_error() if the form has invalid
 * data.
 *
 * @returns boolean true if form has valid data or if no hook is
 * defined in mode
 */
function decisions_vote_validate($node) {
	$mode = _decisions_get_mode($node);
  if (function_exists("decisions_vote_validate_$mode") ) {
    return call_user_func("decisions_vote_validate_$mode", $node);
  }
  return TRUE;
}

/**
 * check if user is eligible to this decision
 */
function decisions_eligible($node, $uid = NULL) {
  global $user;
  if (!isset($uid)) {
    $uid = $user->uid;
  }

	if ($node->uselist) {
  	$can_vote = db_fetch_object(db_query("SELECT COUNT(*) AS eligible FROM {decisions_electoral_list} WHERE nid=%d AND uid=%d", $node->nid, $uid));
	}
	else {
		return user_access('vote on decisions');
	}
  return $can_vote->eligible;
}

/**
 * internal function factored out that just rings lots of bells when
 * we detect an unknown mode
 */
function _decisions_panic_on_mode($mode) {
    watchdog('decisions', t('Unknown decision mode : %mode.', array('%mode' => $mode), WATCHDOG_ERROR));
    drupal_set_message(t('Unknown decision mode : %mode.', array('%mode' => $mode), 'error'));
}

/**
 * internal function to load the available modes.
 *
 * this scans the modes subdirectory to find mode.inc files, where
 * mode is considered to be the mode name. found files are loaded and
 * added to the mode list.
 *
 * @uses _decisions_mode_list()
 * @uses file_scan_directory()
 */
function _decisions_load_modes() {
  global $_decisions_modes;

  foreach (file_scan_directory(dirname(__FILE__) . '/modes/', '^([^\.].*)\.inc$', array('.', '..', 'CVS'), 0, FALSE) as $file) {
          require_once($file->filename);
          $mode = $file->name;
          if ( function_exists("decisions_${mode}_longname") ) {
            _decisions_mode_list($mode, call_user_func("decisions_${mode}_longname"));
          }
          else {
            drupal_set_message("decisions_${mode}_longname ??");
            _decisions_mode_list($mode);
          }

  }
}

/**
 * list or set the known modes
 *
 * @param string $mode set/change the given mode
 * @param string $longname choiceal. set a longname different than the mode name
 *
 * @returns array the module list as a mode => longname associative array
 */
function _decisions_mode_list($mode = NULL, $longname = NULL) {
  static $_decisions_modes = array();

  if (!is_null($mode)) {
    if (is_null($longname)) {
      $longname = $mode;
    }
    $_decisions_modes[$mode] = $longname;
  }
  return $_decisions_modes;
}

?>
