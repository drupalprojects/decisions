<?php

/**
 * Implementation of the decisions_longname() hook
 */
function decisions_runoff_longname() {
  return t("Runoff");
}

/**
 * Implementation of the view_voting_() hook for the runoff module.
 *
 * This displays a textfield per options, that should be filled with a
 * ranking.
 *
 * TODO: make this a nicer UI (http://drupal.org/node/48255)
 */
function decisions_view_voting_runoff(&$node, $teaser, $page, $block) {

  $weight = 0;

  if ($node->option) {
    $list = array();

		$numOptions = count($node->option);

		// Generate the list of possible rankings
		$options[0] = '--';
		for ($i = 1; $i <= $numOptions; $i++) {
			if ($i == 1) {
				$val = t('1st');
			}
			elseif ($i == 2) {
				$val = t('2nd');
			}
			elseif ($i == 3) {
				$val = t('3rd');
			}
			else {
				$val = t(strval($i) . 'th');
			}
			$options[$i] = $val;
		}

    foreach ($node->option as $key => $option) {
      $list[$i] = check_plain($option);

      $form['option']['Option_' . $key] = array(
        '#type' => 'select',
        '#title' => check_plain($option),
        '#required' => FALSE,
        /* XXX: that's not the right way, we need to fetch the vote using votingapi */
/*        '#default_value' => $node->option[$key],*/
				'#options' => $options,
        '#weight' => $weight++,
      );
    }
  }

  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $node->nid,
    '#weight' => $weight++,
  );
  $form['vote'] = array(
    '#type' => 'submit',
    '#value' => t('Vote'),
    '#weight' => $weight++,
  );
  $form['#action'] = url('node/'. $node->nid);
  return drupal_get_form('decisions_view_voting', $form);
}

/**
 * implementation of the decisions_view_results() hook for the runoff
 * module
 *
 * TODO: fix display (http://drupal.org/node/48248)
 */
function decisions_view_results_runoff($node, $teaser, $page, $block) {
    $runoff = _decision_calculate_runoff($node);
    $winning_option = $node->option[$runoff->winner];
    $output = '<p>'.t("The winner is option %option", array('%option' => $winning_option)).'</p>';

    // XXX: debugging code
		if (user_access('administer decisions')) {
    	$output .= "Internal values, for debugging purposes:";
    	// output the table of runoff rounds
    	$output .= "<table border=\"1\"><tr><td>Round</td>";
    	foreach ($node->option as $key => $optionname) {
      	$output .= "<td>$optionname</td>";
    	}
    	$output .= "</tr>";
    	$round = 1;
			if (count($runoff->matrix) > 0)
			{
    		foreach ($runoff->matrix as $aRound) {
      		$output .= "<tr><td>$round.</td>";
      		foreach ($node->option as $key => $optionname) {
        		$output .= "<td>$aRound[$key]</td>";
      		}
      		$output .= "</tr>";
      		$round++;
    		}
			}

    	$output .= "</table>";
		}

    return $output;
}

/**
 * XXX: what does this do?
 */
function _decision_calculate_runoff ($node) {

// Important here: for now, we do not check the weighting of the votes
// in the votes array ($vote->value).  $vote->value should
// be beetween 1 and the max number of options for the runoff.
$votes = _votingapi_get_raw_votes('decisions', $node->nid);

  //calculate the first round
  foreach ($votes as $vote) {
    if ($vote->value == 1) {
         $aRound[$vote->tag]++;
         $totalvotes++;
    }
  }

  /*
   * XXX: This is an horrible hack to avoid using while(true) which
   * was the loop setup before. This isn't better design, but avoids
   * infinite loops.
   */
  $maxiter = 1000;
  for ($i = 0; $i < $maxiter && count($aRound) > 0; $i++) {

    //Add the round to the matrix
    $runoff_matrix[] = $aRound;

    //calculate the min and max number of vote
    $min = 100000000; // weird min
    $num_discarded = 0;
    foreach ($aRound as $votevalue) {

      if ($max < $votevalue) {
       $max = $votevalue;
      }
      if (($min > $votevalue) && ($votevalue != 0)) {
       $min = $votevalue;
      }
      if (!$votevalue) {  // si c'est à zéro, on le compte
       $num_discarded++;
     }
    }

    // is there only two options left?
    $twooptionsleft =  ((sizeof($aRound) - $num_discarded) == 2);


    // if max has the majority, it wins
    // if there is only two options left, choose the best,
    // or the randomly in case of ties
    if (($max > $totalvotes/2) or $twooptionsleft) {
       $runoff->winner = array_search($max, $aRound);
       $runoff->matrix = $runoff_matrix;
       return $runoff;
    }

    // get to the next round
    $aRound = _decision_calculate_runoff_nextround($aRound, $votes, $min);
   }
  // loop detected. signal user and record.
  watchdog('decisions', "could not reach a decision within $maxiter iterations", WATCHDOG_ERROR);
  drupal_set_message("could not reach a decision within $maxiter iterations");
  return array();
}

/**
 * XXX: what does this do?
 */
function _decision_calculate_runoff_nextround($aRound, &$votes, $min) {

   // For Tie-breaking rules, lets implement in this first version the
   // RANDOM: Eliminate one randomly to break the tie.
   // http://en.wikipedia.org/wiki/Instant-runoff_voting

   // What do we need to do here:
   // "The votes for Nashville have Chattanooga as a second choice, but      as Chattanooga has been eliminated, they instead transfer to      their third choice, Knoxville."
   // http://en.wikipedia.org/wiki/Instant-runoff_voting
   // Autrement dit, si le second choix est éliminé, il faut regardé le troisième choix.

   // step 1: find the loser and put 0 to it
   $taglooser = array_search($min, $aRound);  // random elimination
   $aRound[$taglooser] = 0;


   // step 2: lets find which users needs their vote to be redistributed
   $numbervotes_redistributed = 0;
   $preference_value = 0;
   // XXX: what is $stop for?
   while (($numbervotes_redistributed < $min) and $stop < 50){
      $preference_value++;
      foreach ($votes as $vote) {
        // step 2.1: find the users who voted for the loosers
        if (($vote->tag == $taglooser) and
            ($vote->value == $preference_value) ) {
             $voteslosts[] = $vote->uid;
             $numbervotes_redistributed = $numbervotes_redistributed + 1;
         }
       }
       $stop++;
    }

   // step 3: lets find what are the other non-eliminated choices for the ones who voted for the loosers.  Not optimised at all
   foreach ($voteslosts as $voteuid) {
     $minvalue = 0;
    foreach ($votes as $vote) {
       if (($vote->uid == $voteuid) and
	($aRound[$vote->tag] != 0) and
	($aRound[$vote->value] > $minvalue) ) {
             $votesecond[$voteuid] = $vote->tag;
             $vote->value = 1;
             $minvalue = $vote->value;
       	}
     }
   }

   // step 4: distribute the remaining votes of the users
   foreach ($voteslosts as $votelost_uid) {
     $aRound[$votesecond[$votelost_uid]]++;
   }

   return $aRound;
}

/**
 * Implementation of the vote hook for the runoff module.
 *
 * This takes care of registering the vote in runoff nodes.
 */
function decisions_vote_runoff($node) {
  foreach ( $node->option as $key => $option ) {
    $vote->value = $_POST['edit']['Option_' . $key];

		// A zero value indicates they didn't rank that option
		if ($vote->value != 0) {
    	$vote->value_type = VOTINGAPI_VALUE_TYPE_KEY;
    	$vote->tag = $key;
    	votingapi_set_vote('decisions', $node->nid, $vote);
		}
  }
}

/**
 * implementation of the vote validation hook for the runoff module.
 *
 * This checks if the submitted values are within range, if they are
 * not empty, and if they are not repeated.
 *
 * @returns boolean false on invalid forms, true otherwise.
 */
function decisions_vote_validate_runoff($node) {
  $ok = TRUE;
  // array used to check which values are set
  $setvalues = array();
	// TODO: allowing incomplete rankings should be a configurable option
  foreach ( $node->option as $key => $option ) {
    // check for empty entries
    if (empty($_POST['edit']['Option_' . $key])) {
      form_set_error('Option_'.$key, "option $key cannot be empty");
      $ok = FALSE;
    }
    $intvalue = intval($_POST['edit']['Option_' . $key]);
    // mark this value as seen
    $setvalues[$intvalue] = 1;
    // check range
    if ($intvalue > count($node->option) || $intvalue < 1) {
      form_set_error('Option_'.$key, "illegal rank for option $key: $intvalue (min: 1, max: " . count($node->option) . ")");
      $ok = FALSE;
    }
  }
  // by the 'pigeon-hole principle', we must have exactly as many
  // unique answers as we have questions if we don't have repetition.
  if (count($setvalues) != count($node->option)) {
    form_set_error("edit", 'You must set a distinct rank to every entry');
    $ok = FALSE;
  }
  return $ok;
}

?>
