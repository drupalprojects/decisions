<?php

/**
 * Implementation of the decisions_longname() hook
 */
function decisions_runoff_longname() {
  return t("Runoff");
}

/**
 * Implementation of the view_voting_() hook for the runoff module.
 *
 * This displays a textfield per options, that should be filled with a
 * ranking.
 *
 * TODO: make this a nicer UI (http://drupal.org/node/48255)
 */
function decisions_view_voting_runoff(&$node, $teaser, $page, $block) {
  if ($node->option) {
    $list = array();
    foreach ($node->option as $key => $option) {
      $list[$i] = check_plain($option);

      $form['OptionGroup']['Option_' . $key] = array(
        '#type' => 'textfield',
        '#title' => check_plain($option),
        '#required' => FALSE,
        /* XXX: that's not the right way, we need to fetch the vote */
/*        '#default_value' => $node->option[$key],*/
        '#size' => 3,
        '#maxlength' => 3,
      );
    }
  }

  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $node->nid
  );
  $form['vote'] = array(
    '#type' => 'submit',
    '#value' => t('Vote')
  );
  $form['#action'] = url('node/'. $node->nid);
  return drupal_get_form('decisions_view_voting', $form);
}

/**
 * implementation of the decisions_view_results() hook for the runoff
 * module
 *
 * TODO: fix display (http://drupal.org/node/48248)
 */
function decisions_view_results_runoff($node, $teaser, $page, $block) {
    $runoff = _decision_calculate_runoff($node);
    $winning_option = $node->option[$runoff->winner];
    $output = "The winner is option $winning_option";
    
    // On output la table 
    $output .= "<table><tr><td>round</td>";
    foreach ($node->option as $key => $optionname) {
      $output .= "<td>$optionname</td>";
    }
    $output .= "</tr>";
    $round = 1;
    foreach ($runoff->matrix as $aRound) {
      $output .= "<tr><td>r-$round</td>";
      foreach ($node->option as $key => $optionname) { 
        $output .= "<td>$aRound[$key]</td>";
      }
      $output .= "</tr>";
      $round = $round + 1;
    }
     
 
    $output .= "</table>";
    return $output;
}

function _decision_calculate_runoff ($node) {

// Important here: for now, we do not check the weighting of the votes 
// in the votes array ($vote->value).  $vote->value should 
// be beetween 1 and the max number of options for the runoff.
$votes = _votingapi_get_raw_votes('decisions', $node->nid);
 
  //calculate the first round
  foreach ($votes as $vote) {
    if ($vote->value == 1) {
         $aRound[$vote->tag] = $aRound[$vote->tag] + 1;
         $totalvotes = $totalvotes + 1;
    }
  }
  
  $maxiter = 1000;
  for ($i = 0; $i < $maxiter; $i++) {

    //Add the round to the matrix 
    $runoff_matrix[] = $aRound;

    //calculate the min and max number of vote
    $min = 100000000; // weird min
    $num_discarded = 0;
    foreach ($aRound as $votevalue) {

      if ($max < $votevalue) {
       $max = $votevalue;
      }
      if (($min > $votevalue) && ($votevalue != 0)) {
       $min = $votevalue;
      }
      if (!$votevalue) {  // si c'est à zéro, on le compte
       $num_discarded = $num_discarded + 1;
     }
    }

    // is there only two options left?
    $twooptionsleft =  ((sizeof($aRound) - $num_discarded) == 2);

   
    // if max has the majority, it wins
    // if there is only two options left, choose the best, 
    // or the randomly in case of ties
    if (($max > $totalvotes/2) or $twooptionsleft) {
       $runoff->winner = array_search($max, $aRound);
       $runoff->matrix = $runoff_matrix;
       return $runoff;
    }

    // get to the next round
    $aRound = _decision_calculate_runoff_nextround($aRound, $votes, $min);
   }
  watchdog('decisions', "could not reach a decision within $maxiter iterations", WATCHDOG_ERROR);
  drupal_set_message("could not reach a decision within $maxiter iterations");
  return array();
}

function _decision_calculate_runoff_nextround($aRound, &$votes, $min) {

   // For Tie-breaking rules, lets implement in this first version the 
   // RANDOM: Eliminate one randomly to break the tie.
   // http://en.wikipedia.org/wiki/Instant-runoff_voting

   // What do we need to do here: 
   // "The votes for Nashville have Chattanooga as a second choice, but      as Chattanooga has been eliminated, they instead transfer to      their third choice, Knoxville."
   // http://en.wikipedia.org/wiki/Instant-runoff_voting
   // Autrement dit, si le second choix est éliminé, il faut regardé le troisième choix. 

   // step 1: find the loser and put 0 to it
   $taglooser = array_search($min, $aRound);  // random elimination
   $aRound[$taglooser] = 0;


   // step 2: lets find which users needs their vote to be redistributed
   $numbervotes_redistributed = 0;
   $preference_value = 0;
   while (($numbervotes_redistributed < $min) and $stop < 50){
      $preference_value = $preference_value + 1;
      foreach ($votes as $vote) {
        // step 2.1: find the users who voted for the loosers
        if (($vote->tag == $taglooser) and 
            ($vote->value == $preference_value) ) {
             $voteslosts[] = $vote->uid;
             $numbervotes_redistributed = $numbervotes_redistributed + 1;
         }
       }
       $stop = $stop+1;
    }

   // step 3: lets find what are the other non-eliminated choices for the ones who voted for the loosers.  Not optimised at all
   foreach ($voteslosts as $voteuid) {
     $minvalue = 0;
    foreach ($votes as $vote) {
       if (($vote->uid == $voteuid) and 
	($aRound[$vote->tag] != 0) and 
	($aRound[$vote->value] > $minvalue) ) {
             $votesecond[$voteuid] = $vote->tag;
             $vote->value = 1;
             $minvalue = $vote->value;
       	} 	
     }
   }

   // step 4: distribute the remaining votes of the users
   foreach ($voteslosts as $votelost_uid) {
     $aRound[$votesecond[$votelost_uid]] += 1;
   }

   return $aRound;
}

/**
 * Implementation of the vote hook for the runoff module.
 *
 * This takes care of registering the vote in runoff nodes.
 */
function decisions_vote_runoff($node) {
  foreach ( $node->option as $key => $option ) {
    $vote->value = $_POST['edit']['Option_' . $key];
    $vote->value_type = VOTINGAPI_VALUE_TYPE_KEY;
    $vote->tag = $key;
    votingapi_set_vote('decisions', $node->nid, $vote);
  }
}

?>