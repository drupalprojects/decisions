<?php

/**
 * @file
 *
 * This file implements a selection voting mode
 *
 */

function selection_help($section) {
  switch ($section) {
  case 'node/add#decisions-selection':
    return t('Creates a decision where the user selects one or many options.');
  }
}

function selection_menu($may_cache) {
  $items[] = array('path' => 'node/add/decisions-selection',
                   'title' => 'decisions-selection',
                   'access' => user_access('create decisions'),
                   );
  return $items;
}

function selection_node_info() {
  return array('decisions_selection' => array('name' => t('Decisions - selection'), 'module' => 'decisions', 'description' => t('Creates a decision where the user selects one or many options.')));
}

/**
 * Implementation of the decisions_algorithms() hook
 */
function selection_decisions_algorithms() {
  return array('plurality');
}

/**
 * Implementation of the decisions_voting_hook_form() hook for the selection module.
 * 
 * This creates a list of choices to allow the user to vote on choices.
 */
function selection_decisions_voting_form(&$node, $teaser, $page) {
  if ($node->choice) {
    $list = array();

    if ($node->maxchoices == 1) {
      // plurality voting
      foreach ($node->choice as $i => $choice) {
        if ($choice['label']) {
          $list[$i] = check_plain($choice['label']);
        }
      }

      $form['choice'] = array(
                              '#type' => 'radios',
                              '#title' => $page ? '' : check_plain($node->title),
                              '#default_value' => -1,
                              '#options' => $list
                              );
    }
    else {
      // approval voting
      foreach ($node->choice as $i => $choice) {
        if ($choice['label']) {
          $list[$i] = check_plain($choice['label']);
        }
      }
      $form['choice'] = array(
                              '#type' => 'checkboxes',
                              '#title' => $page ? '' : check_plain($node->title),
                              '#options' => $list,
                              );
    }
  }
  $form['nid'] = array(
                       '#type' => 'hidden',
                       '#value' => $node->nid
                       );
  $form['vote'] = array(
                        '#type' => 'submit',
                        '#value' => t('Vote')
                        );
  $form['#action'] = url('node/'. $node->nid);
  return $form;
}

/**
 * Implementation of the decisions_view_results() hook for the selection module
 *
 * TODO: implement (http://drupal.org/node/48249)
 */
function selection_decisions_view_results($node, $teaser, $page) {

  $output = "";
  $results = votingapi_get_voting_results('decisions', $node->nid);

  // Count the votes for each choice
  $votes = array();
  foreach ($results as $result) {

    // approval
    $voteval = $result->tag;
    
    if (!$votes[$voteval]) {
      $votes[$voteval] = 0;
    }
    // Not sure if this can just be = rather than +=
    $votes[$voteval] += $result->value;
  }

  $total_votes = count($votes);
  if ($node->choice && $total_votes > 0) {
    // TODO: Those <div>s and <br />s should be in a theme function. First collect all the data in a structure, then theme it.
    // display results for each possible choice
    $output .= '<div class="poll">';
    foreach ($node->choice as $i => $ch) {
      if (!$votes[$i]) {
        $votes[$i] = 0;
      }
      $percentage = round(100 * $votes[$i] / array_sum($votes), 0);
      $output .= theme('decisions_bar',  check_plain($ch['label']), $percentage, format_plural($votes[$i], '1 vote', '@count votes'));
    }
    $output .= '</div>';
  }

  $output .= '<br />';
  return $output;
}

/**
 * implementation of the format_votes() hook.
 * 
 * formats how a user's votes should be displayed.
 *
 * @returns a formatted string
 */
function selection_decisions_format_votes($node, $votes) {
  $unordered_votes = array();
  foreach ($votes as $vote) {
    // Just need one dimensional results
    if ($vote->value > 0) {
      $unordered_votes[] = check_plain($node->choice[$vote->tag]['label']);
    }
  }
  return implode(', ', $unordered_votes);
}


/**
 * implementation of the submit() hook
 *
 * registers the vote as a key for this node using votingapi_set_vote()
 */
function selection_decisions_vote($node, $form_values) {
  $votes = array();
  if ($node->maxchoices == 1) {
    // plurality voting
    $vote = new stdClass();
    $vote->value = 1;
    $vote->tag = $form_values['choice'];
    $vote->value_type = 'option';
    $votes[] = $vote;
  }
  else {
    // approval voting
    foreach ($node->choice as $key => $choice) {
      if (isset($form_values['choice'][$key])) {
        $vote = new stdClass();
        $vote->value = $form_values['choice'][$key];
        $vote->value_type = 'option';
        $vote->tag = $key;
        $votes[] = $vote;
      }
    }
  }
  votingapi_set_vote('decisions', $node->nid, $votes);
}

/**
 * implementation of the vote_validate() hook
 *
 * check if the submitted key exists, just to make sure the form is not bypassed.
 *
 * @returns boolean true if the form is valid
 */
function selection_decisions_vote_validate($node, $form_values) {
  $ok = TRUE;
  if ($node->maxchoices == 1) {
    // plurality voting
    if (!array_key_exists($form_values['choice'], $node->choice)) {
      form_set_error('choice', 'At least one choice must be selected.');
      $ok = FALSE;
    }
  }
  else {
    // approval voting

    // array used to check which values are set
    $setvalues = array();
    foreach ($node->choice as $key => $choice) {

      // need a minchoices choice to do this
      //if (empty($_POST['edit']['Choice_' . $key])) {
      //form_set_error('Choice_'.$key, "choice $key cannot be empty");
      //$ok = FALSE;
      //}

      // see if the box is checked
      if (!empty($form_values['choice'][$key])) {
        $numchoices++;
      }
    }
        
    // too many choices ranked
    if ($node->maxchoices != 0 && $numchoices > $node->maxchoices) {
      form_set_error('choice',
                     t('%num choices were selected but only %max are allowed.',
                       array('%num' => $numchoices, '%max' => $node->maxchoices)));
      $ok = false;
    }

    // not enough choices ranked
    $minchoices = 1;
    if ($numchoices < $minchoices) {
      form_set_error('choice', t('At least one choice must be selected.'));
      $ok = false;
    }
  }
  return $ok;
}

